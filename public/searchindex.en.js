var relearn_searchindex = [
  {
    "breadcrumb": "Welcome",
    "content": "Welcome to my technical blog and knowledge base!\nTopics üñ• Threathunting Tutorials üñ• OpenBSD Latest posts Threathunting I: Network setup 08.07.2025 Threat hunting II: SSH Honeypot setup 13.07.2025 Fixing Yellow Shards in Elasticsearch 12.11.2025 Get in Touch Suggestions or feedback?\nContact me here or visit the project repository.\nYou can also subscribe via RSS.",
    "description": "Latest posts",
    "tags": [],
    "title": "Forensic wheels",
    "uri": "/posts/index.html"
  },
  {
    "breadcrumb": "",
    "content": "Welcome to my technical blog and knowledge base!\nTopics üñ• Threathunting Tutorials üñ• All things OpenBSD Latest posts Threathunting I: Network setup 08.07.2025 Threat hunting II: SSH Honeypot setup 13.07.2025 Fixing Yellow Shards in Elasticsearch 12.11.2025 Get in Touch Suggestions or feedback?\nContact me here or visit the project repository.\nYou can also subscribe via RSS.",
    "description": "Latest posts",
    "tags": [],
    "title": "Welcome",
    "uri": "/index.html"
  },
  {
    "breadcrumb": "Welcome¬†\u003e¬†Forensic wheels",
    "content": "Introduction Why I Built a Home Lab for Threat Hunting üïµ Network Setup Topology, Hardware and Tools üõ† Firewall configurationüß± Switch configuration What I Learned Whats next Introduction This is a small series I wanted to start, where I write about my small threathunting setup and describe a little what I build and what I am doing with it.\nIn this part, I will describe the Network setup for my Environment, more about how I build the honeypots and the ELK Server I will describe in the follow up articles about threathunting.\nKeep in mind this is for Education and fun, no serious stuff going on here.\nWhy I Built a Home Lab for Threat Hunting üïµ The threat landscape is constantly evolving, with new attack vectors, tools, and tactics appearing almost daily.\nAnd to keep my skills current with real-world threats, I built a home lab dedicated to threat hunting. This environment allows me to safely observe attacks and develop detection and defense methods. I deployed web and shell honeypots, and collect real threat data in a controlled setting.\nIt‚Äôs a practical, hands-on way to explore the behavior of adversaries and its a lot of fun!\nNetwork Setup Topology, Hardware and Tools üõ† For the hardware setup, I kept things lightweight and affordable by using Raspberry Pi devices and open-source tools. The honeypot is based on the well-known Cowrie SSH honeypot and the honeyhttpd HTTP honeypot . It runs on a Raspberry Pi 4 with 8GB of RAM, hosted inside a Docker üê≥ container. On the honeypot host, Filebeat is running to ingest the Cowrie logs into the ELK stack.\nFor the ELK stack, I used a Raspberry Pi 5 with 16GB of RAM, running Debian. The ELK services are also containerized using Docker. The stack is based on the DShield-SIEM project, which I customized to better fit my needs. I‚Äôll dive deeper into those modifications and the ELK setup in a follow-up article.\nThe network topology is straightforward but deliberately segmented. The router is connected to a managed switch, which is responsible for handling VLAN separation. Both the honeypot and the ELK server are connected to this switch and are placed in an isolated VLAN (VLAN210). This VLAN is dedicated exclusively to threat hunting, ensuring that any potentially malicious traffic remains fully contained and cannot interfere with the rest of the home network.\nMy client system üíª is the only machine allowed to connect from outside the VLAN to both the ELK server and the honeypot. This connection is strictly for maintenance and administrative purposes. The ELK server is allowed to access the internet, primarily to pull threat intelligence data from external sources and security feeds.\nIn contrast, the honeypot is completely blocked from internet access, with the exception of SSH and HTTP traffic going in and out of it. These are the only services deliberately exposed to simulate vulnerable endpoints. Communication between the honeypot and the ELK server is allowed for log ingestion and analysis. However, I intend to introduce stricter controls on this internal traffic in the future to further reduce the attack surface.\nFirewall configurationüß± For the pf(1) configuration It was as always with UNIX fairly easy to get to work:\nmatch in quick log on egress proto tcp from any to any port 22 flags S/SA rdr-to $honeypot port 2222 match in quick log on egress proto tcp from any to any port 443 flags S/SA rdr-to $honeypot port 4433 This rule makes sure any incoming TCP connection attempt to port 22 (SSH) and port 443 (HTTPS) is immediately intercepted, logged, and transparently redirected to the $honeypot server listening on port 2222 or 4433 for HTTPS Traffic.\nSwitch configuration Here you can see my managed switch configuration. Port 5 (honeypot) and port 3 (ELK) is assigned to VLAN210, port 2 is the router it needs to talk into both networks and at port 1 is my workstation to access the theathunting environment.\nWhat I Learned Building and maintaining this lightweight honeypot and monitoring setup on Raspberry Pi devices has been an insightful experience. Here are some key takeaways:\nResource Efficiency: Raspberry Pis provide a surprisingly capable platform for running complex services like Cowrie honeypot and the ELK stack in Docker containers, keeping costs and power consumption low.\nNetwork Segmentation Matters: Isolating the honeypot and ELK server in a dedicated VLAN (VLAN210) effectively contains malicious traffic, protecting the rest of the home network from potential threats.\nControlled Access Is Crucial: Restricting external access to only authorized clients and limiting the honeypot‚Äôs internet connectivity reduces the attack surface while still enabling useful data collection.\nLogging and Data Collection: Using Filebeat to ship logs from the honeypot to the ELK stack provides real-time visibility into attacker behavior, which is essential for threat hunting and incident response.\nCustomization Pays Off: Adapting existing tools and SIEM projects (like DShield) to specific needs improves effectiveness and allows for tailored threat detection.\nFuture Improvements: There is always room to tighten internal communication rules and harden the setup further to minimize risk and improve operational security.\nThis project highlights the balance between practical constraints and security needs, demonstrating that even modest hardware can contribute significantly to threat intelligence and network defense.\nI drew inspiration for this setup from the DShield SIEM project by SANS and would like to express my gratitude for their valuable work.\nWhats next Next I had to build the ssh honeypot and the HTTP Honeypot, stay tuned for the follow up!",
    "description": "Introduction Why I Built a Home Lab for Threat Hunting üïµ Network Setup Topology, Hardware and Tools üõ† Firewall configurationüß± Switch configuration What I Learned Whats next Introduction This is a small series I wanted to start, where I write about my small threathunting setup and describe a little what I build and what I am doing with it.",
    "tags": [
      "Threathunting",
      "Honeypot",
      "Visibility"
    ],
    "title": "Threathunting I: Network setup",
    "uri": "/posts/threathuntingnet/index.html"
  },
  {
    "breadcrumb": "Welcome",
    "content": "Hi, I‚Äôm Dirk ‚Äî a security engineer with a deep passion for skateboarding and digital forensics.\nSkateboarding is more than a hobby to me; it‚Äôs a source of creativity, freedom, and community. It shapes how I approach challenges ‚Äî with persistence, balance, and a mindset open to innovation.\nBeyond that, I‚Äôm an OpenBSD enthusiast. I‚Äôve built an OpenBSD-based router and threat-hunting infrastructure to stay ahead in cybersecurity. I appreciate OpenBSD for its simplicity, security, and elegance ‚Äî qualities I strive to bring to my work.\nI‚Äôm also a longtime Emacs user, relying on it daily for coding, writing, and organizing my thoughts. It‚Äôs part of how I stay productive and focused.\nIn cybersecurity, I‚Äôm committed to continuous growth and adapting to new challenges. When I‚Äôm not working on security projects, you‚Äôll find me skating or exploring new ideas inspired by Zen philosophy.\nYou can download my CV as a signed and encrypted PDF for authenticity and privacy. If you need the password to decrypt it, please send me an E-mail\nStay tuned for updates on my journey as a security engineer, skateboarder, and lifelong learner.\nKey ID: `0xC2920C559CAD6CB` Fingerprint: `40CA 727E 96D3 CC2D 8CBB 1540 0C29 20C5 59CA D6CB` SHA-256 Hash: `c7359e0e8bd69ed7cee3ea97453c10e327bfe2416822f54c6390efe72b0d6e7a` publickey",
    "description": "Short intro about myself",
    "tags": [
      "Forensicwheels",
      "Personal"
    ],
    "title": "about",
    "uri": "/about/index.html"
  },
  {
    "breadcrumb": "Welcome¬†\u003e¬†Forensic wheels",
    "content": "Introduction What is Cowrie? Why Podman over Docker? Preconditions / System setup Ubuntu Installed on Raspberry Pi 4+ System Fully Updated Podman installed and working VLAN Tagging Configured on Network Interface Setup environment, install cowrie as container and adjust configuration üêß Create a Dedicated User for Cowrie (No Login Shell) üê≥ Pull and Configure Cowrie with Podman üõ† cowrie.cfg ‚Äì Basic Overview üöÄ Run Cowrie Container as ‚Äòcowrie‚Äô User üéØ Operating the Honeypot üîÑ Automatically Restart Cowrie Podman Container with systemd üîí Security Notes Log Forwarding with Filebeat üì¶ Install Filebeat on Ubuntu ‚öô Configure and test Filebeat üöÄ Start and Enable Filebeat üéØ TL;DR ‚Äì What Did We Just Do? Whats next Introduction This post provides a brief walkthrough of how to deploy a lightweight, containerized SSH honeypot using Cowrie and Podman, with the goal of capturing and analyzing malicious activity as part of my threat hunting strategy.\nWhat is Cowrie? Cowrie is an interactive SSH and Telnet honeypot designed to emulate a real system, capturing attacker behavior in a controlled environment. It allows defenders and researchers to observe malicious activity without exposing actual infrastructure.\nKey capabilities of Cowrie include\nFull session logging: Records all commands entered by the attacker, along with input/output streams and timing data. Sessions can be saved as plaintext or in formats suitable for replay.\nFake file system and shell environment: Emulates a basic Linux shell with a user-modifiable file system. Attackers can navigate directories, read/write fake files, or attempt to download/upload payloads.\nCommand emulation: Supports a large set of common Unix commands (`ls`, `cat`, `wget`, etc.), allowing attackers to interact naturally, as if on a real system. And can be extended with more commands\nCredential logging: Captures usernames and passwords used in brute-force login attempts or interactive logins.\nFile download capture: Logs and optionally stores any files attackers attempt to retrieve via `wget`, `curl`, or similar tools.\nJSON-formatted logging and integration‚Äôs: Outputs structured logs that are easy to parse and ingest into systems like ELK, Splunk, or custom analysis pipelines.\nCowrie is widely used in research, threat intelligence, and proactive defense efforts to gather Indicators of Compromise (IOCs) and understand attacker tactics,techniques, and procedures (TTPs).\nWhy Podman over Docker? Podman offers several advantages over Docker, particularly in terms of security and system integration. It supports rootless containers, allowing users to run containers without elevated privileges, which reduces the attack surface.\nPodman is daemon-less, integrating more seamlessly with systemd and existing Linux workflows. Additionally, Podman is fully compatible with the Open Container Initiative (OCI) standards, ensuring interoperability and flexibility across container ecosystems.\nPreconditions / System setup Before I proceed with the cowrie setup, I made sure the following preconditions are met:\nUbuntu Installed on Raspberry Pi 4+ I am using a Raspberry Pi 4+ running Ubuntu\nSystem Fully Updated After installation, I made sure system is up to date:\nsudo apt update \u0026\u0026 sudo apt upgrade -y Podman installed and working # Ubuntu 20.10 and newer sudo apt-get -y install podman Run the Hello World Container.In this moment I did not had the cowrie user yet setup so I used my system user to test\npodman run hello-world Trying to pull docker.io/library/hello-world:latest... ... Hello from Docker! This message shows that your installation appears to be working correctly. tho sometimes the pulling fails like that then I had to put `docker.io` in front of the container name like:\npodman run docker.io/hello-world then it would work for sure.\nVLAN Tagging Configured on Network Interface In my network setup for threathunting the honeypot requires VLAN tagging to configured to reachable from the outside, VLAN210 is my restricted Network. Therefore i needed to configure the vlan using nmcli so it‚Äôs persistent across reboots.\nExample: Create a VLAN interface (e.g., VLAN ID 210 on main if) sudo nmcli con add type vlan con-name vlan210 dev mainif id 210 ip4 192.168.210.3/24 gw4 192.168.210.1 sudo nmcli con up vlan210 con-name vlan210: Name of the new VLAN connection. dev mainif: Physical interface to tag. id 210: VLAN ID. ip4, gw4: Optional IP and gateway assignment. This will persist the configuration and activate the VLAN interface immediately. Next I moved on to Install the honeypot.\nSetup environment, install cowrie as container and adjust configuration üêß Create a Dedicated User for Cowrie (No Login Shell) Running the Podman container under a dedicated system user with no login shell is a recommended security best practice. Reasons include:\nPrivilege Separation: Isolates the container from other system processes and users, limiting the potential impact of a compromise.\nReduced Attack Surface: The user has no login shell (e.g., /usr/sbin/nologin), meaning it can‚Äôt be used to log into the system interactively.\nAuditing \u0026 Logging: Helps distinguish container activity in system logs and process lists, making monitoring easier.\nLeast Privilege Principle: The user has only the permissions necessary to run the container ‚Äî nothing more.\n1. Create the ‚Äòcowrie‚Äô user (no home directory, no login shell)\nsudo useradd --system --no-create-home --shell /usr/sbin/nologin cowrie 2. Create necessary directories and set ownership\nsudo mkdir -p /opt/cowrie/etc sudo mkdir -p /opt/cowrie/var sudo mkdir -p /opt/cowrie/var/log/cowrie sudo chown -R cowrie:cowrie /opt/cowrie üê≥ Pull and Configure Cowrie with Podman 3. As the cowrie user, pull the container image\nsudo -u cowrie podman pull docker.io/cowrie/cowrie 4. Copy default config file into persistent volume\nsudo -u cowrie podman run --rm localhost/cowrie_honeypot:latest \\ cat /cowrie/cowrie-git/etc/cowrie.cfg.dist \u003e /opt/cowrie/etc/cowrie.cfg üõ† cowrie.cfg ‚Äì Basic Overview The `cowrie.cfg` file is the main configuration for Cowrie, the SSH/Telnet honeypot we use. It uses INI-style syntax and is divided into sections. Each section begins with a header like [section_name].\nüìÅ Key Sections \u0026 Settings\n[ssh]\nEnable or disable SSH/Telnet and set the port to listen on:: enabled = true listen_port = 2222 [honeypot]\nSet honeypot host name and logpath properties:\nhostname = cowrie-host # Directory where to save log files in. log_path = var/log/cowrie Define login behavior:\nauth_class = AuthRandom auth_class_parameters = 1, 5, 10 I use AuthRandom here which causes to allow access after ‚Äúrandint(2,5)‚Äù attempts. This means the threat actor will fail with some logins and some will be logged in immediately.\n[output_jsonlog]\nConfigure logging and output plugins: [output_jsonlog] enabled = true logfile = ${honeypot:log_path}/cowrie.json epoch_timestamp = false This sets the default log location in the file-system, this is important so that file beat later can pickup on the juicy honeypot log files. This is the whole configuration needed to run the honeypot.\nüìå Notes\nRestart Cowrie after configuration changes. The configuration can be split across multiple `.cfg` files in `cowrie.cfg.d/` for modular setup. üöÄ Run Cowrie Container as ‚Äòcowrie‚Äô User Once I had created the dedicated system user (see earlier section), I was able to run the Cowrie container with Podman using sudo -u and UID mapping.\nStep-by-Step Command explanation sudo -u cowrie podman run -d --name cowrie \\ --uidmap 0:999:1001 \\ -v /opt/cowrie/etc:/cowrie/cowrie-git/etc:Z \\ -v /opt/cowrie/var:/cowrie/cowrie-git/var:Z \\ -p 2222:2222 \\ cowrie/cowrie Explanation sudo -u cowrie: Runs the Podman command as the unprivileged cowrie user. --uidmap 0:999:1001: Maps root (UID 0) inside the container to the cowrie UID on the host. -v /opt/cowrie/etc and /opt/cowrie/var: Mounts configuration and data volumes from the host with `:Z` to apply correct SELinux labels (optional on systems without SELinux). -p 2222:2222: Forwards port 2222 from host to container (Cowrie‚Äôs SSH honeypot port). cowrie/cowrie: The container image name (use latest or specific tag as needed). Benefits: Container runs as non-root on the host: Even if a process inside the container thinks it‚Äôs root, it‚Äôs actually limited to the unprivileged cowrie user outside the container.\nEnhanced security: If the container is compromised, the attacker only gets access as the cowrie user ‚Äî not real root.\nAvoids root-equivalent risks: Prevents privilege escalation or access to sensitive host files and devices.\nüéØ Operating the Honeypot View logs I think to know how to debug the container is important so we start first with the logs:\nsudo -u cowrie podman logs -f cowrie ...snip... [HoneyPotSSHTransport,14,10.0.2.100] Closing TTY Log: var/lib/cowrie/tty/e52d9c508c502347344d8c07ad91cbd6068afc75ff6292f062a09ca381c89e71 after 0.8 seconds [cowrie.ssh.connection.CowrieSSHConnection#info] sending close 0 [cowrie.ssh.session.HoneyPotSSHSession#info] remote close [HoneyPotSSHTransport,14,10.0.2.100] Got remote error, code 11 reason: b'disconnected by user' [HoneyPotSSHTransport,14,10.0.2.100] avatar root logging out [cowrie.ssh.transport.HoneyPotSSHTransport#info] connection lost [HoneyPotSSHTransport,14,10.0.2.100] Connection lost after 2.8 seconds ...snip... Restart container If things go left just restart that thing:\nsudo -u cowrie podman restart cowrie In the logs you can see that cowrie is running and accepting SSH connections:\n...snip... [-] CowrieSSHFactory starting on 2222 [cowrie.ssh.factory.CowrieSSHFactory#info] Starting factory \u003ccowrie.ssh.factory.CowrieSSHFactory object at 0x7fb66f26d0\u003e [-] Ready to accept SSH connections ...snip... When the log says ‚ÄúReady to accept SSH connections‚Äù I tested if I could login:\nssh 192.168.210.3 -p 2222 -l root root@192.168.210.3 password: The programs included with the Debian GNU/Linux system are free software; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. root@svr04:~# uname -a Linux svr04 3.2.0-4-amd64 #1 SMP Debian 3.2.68-1+deb7u1 x86_64 GNU/Linux root@svr04:~# Stop container Nothing special here:\nsudo -u cowrie podman stop cowrie üîÑ Automatically Restart Cowrie Podman Container with systemd To keep your Cowrie container running reliably and restart it if it stops, use a systemd service with restart policies. Please make sure to double check this part on your side as I am no systemd expert at all, for me this just worked.\nStep 1: Generate a systemd Service File Create `/etc/systemd/system/cowrie-container.service` with the following content: You can create the systemd file with the command:\nsudo -u cowrie podman generate systemd --name cowrie --files --restart-policy=on-failure The resulting file looks somewhat like this\n# container-cowrie.service # autogenerated by Podman 4.3.1 # Fri Sep 19 10:27:47 CEST 2025 [Unit] Description=Podman container-cowrie.service Documentation=man:podman-generate-systemd(1) Wants=network-online.target After=network-online.target RequiresMountsFor=/run/user/1001/containers [Service] User=cowrie Group=cowrie Restart=on-failure Environment=PODMAN_SYSTEMD_UNIT=%n Restart=on-failure TimeoutStopSec=70 ExecStart=/usr/bin/podman start -a cowrie ExecStop=/usr/bin/podman stop -t 10 cowrie ExecStopPost=/usr/bin/podman stop -t 10 cowrie Type=forking [Install] WantedBy=default.target The `‚Äìrestart-policy=on-failure` makes systemd restart the container if it exits with a failure. Step 2: Enable the Service sudo systemctl daemon-reload sudo systemctl enable --now cowrie-container.service Step 3: (Optional) Add a Health Check Script To detect if Cowrie stops accepting connections even if the container is still running, create a health check script running as cowrie:\nCreate `/usr/local/bin/check_cowrie.sh`:\n#!/bin/bash if ! nc -z localhost 2222; then echo \"Cowrie not responding, restarting container\" /usr/bin/podman restart cowrie /usr/local/bin/pushover.sh \"Cowrie was restarted!\" fi This restarts the service and sends out a notification via pushover.\nMake it executable:\nsudo chmod +x /usr/local/bin/check_cowrie.sh sudo chown cowrie:cowrie /usr/local/bin/check_cowrie.sh Create systemd service `/etc/systemd/system/check_cowrie.service`:\n[Unit] Description=Check Cowrie honeypot health [Service] User=cowrie Group=cowrie Type=oneshot ExecStart=/usr/local/bin/check_cowrie.sh Create systemd timer `/etc/systemd/system/check_cowrie.timer`:\n[Unit] Description=Run Cowrie health check every minute [Timer] OnBootSec=1min OnUnitActiveSec=1min Unit=check_cowrie.service [Install] WantedBy=timers.target Enable and start the timer:\nsudo systemctl daemon-reload sudo systemctl enable --now check_cowrie.timer Summary Used Podman‚Äôs systemd integration for automatic restart on container failure. Added a health check timer to detect if Cowrie stops accepting connections and restart proactively. üîí Security Notes The `cowrie` user has no login shell (`/usr/sbin/no login`)\nRunning Cowrie isolated via Podman increases containment\nAll files are owned by `cowrie`, no root access required for normal operation\nLog Forwarding with Filebeat üì¶ Install Filebeat on Ubuntu 1. Add Elastic‚Äôs GPG key and repository\ncurl -fsSL https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo gpg --dearmor -o /usr/share/keyrings/elastic.gpg echo \"deb [signed-by=/usr/share/keyrings/elastic.gpg] https://artifacts.elastic.co/packages/8.x/apt stable main\" | \\ sudo tee /etc/apt/sources.list.d/elastic-8.x.list 2. Update APT and install Filebeat\nsudo apt install filebeat ‚öô Configure and test Filebeat 3. Edit Filebeat config\nsudo mg /etc/filebeat/filebeat.yml The filebeat config is straight forward. You have to write a filebeat.input block which contains the path where the logfiles are you need to ingest. And at the end the log-destination (logstash) so that filebeat knows where to send the logs to:\nfilebeat.inputs: - type: log enabled: true paths: - /opt/cowrie/var/log/cowrie/cowrie.json json.keys_under_root: true json.add_error_key: true fields: source: cowrie fields_under_root: true output.logstash: hosts: [\"192.168.123.5:5044\"] 4. (Optional) Test Filebeat config\nsudo filebeat test config logstash: 192.168.210.5:5044... connection... parse host... OK dns lookup... OK addresses: 192.168.210.5 dial up... OK TLS... WARN secure connection disabled talk to server... OK üöÄ Start and Enable Filebeat 5. Enable and start Filebeat\nsudo systemctl enable filebeat sudo systemctl daemon-reload sudo systemctl start filebeat 6. Check Filebeat status and logs\nsudo systemctl status filebeat sudo journalctl -u filebeat -f üéØ TL;DR ‚Äì What Did We Just Do? 1. We deployed Cowrie like pros.\nRan it safely in a Podman container under a non-login user. No mess, no root, no regrets. 2. Logs? Sorted.\nFilebeat scooped up Cowrie‚Äôs logs and shipped them to Elasticsearch. Now we can actually see who‚Äôs knocking on the honeypot door. 3. Everything‚Äôs persistent.\nConfigs and logs live outside the container. Cowrie forgets nothing‚Äîeven after a reboot. 4. Setup is clean and modular.\nEach part (Cowrie, Filebeat, Elasticsearch) does its job. Break one, fix one‚Äîno domino disasters. 5. It‚Äôs nerdy, useful, and kinda fun.\nNow I built a mini threat intel system. Now I can sit back, sip coffee, and watch the kiddies play. Whats next Next I build the HTTP Honeypot",
    "description": "Introduction What is Cowrie? Why Podman over Docker? Preconditions / System setup Ubuntu Installed on Raspberry Pi 4+ System Fully Updated Podman installed and working VLAN Tagging Configured on Network Interface Setup environment, install cowrie as container and adjust configuration üêß Create a Dedicated User for Cowrie (No Login Shell) üê≥ Pull and Configure Cowrie with Podman üõ† cowrie.cfg ‚Äì Basic Overview üöÄ Run Cowrie Container as ‚Äòcowrie‚Äô User üéØ Operating the Honeypot üîÑ Automatically Restart Cowrie Podman Container with systemd üîí Security Notes Log Forwarding with Filebeat üì¶ Install Filebeat on Ubuntu ‚öô Configure and test Filebeat üöÄ Start and Enable Filebeat üéØ TL;DR ‚Äì What Did We Just Do? Whats next Introduction This post provides a brief walkthrough of how to deploy a lightweight, containerized SSH honeypot using Cowrie and Podman, with the goal of capturing and analyzing malicious activity as part of my threat hunting strategy.",
    "tags": [
      "Threathunting",
      "Honeypot"
    ],
    "title": "Threat hunting II: SSH Honeypot setup",
    "uri": "/posts/theathuntinghoneypot/index.html"
  },
  {
    "breadcrumb": "Welcome¬†\u003e¬†Forensic wheels",
    "content": "Introduction If you‚Äôre running Elasticsearch on a single node ‚Äî like a Raspberry Pi or small lab setup ‚Äî you might notice some indices appear with a yellow health status.\nThis article explains what that means and how to fix it, especially in resource-constrained, single-node environments.\nWhat Does ‚ÄúYellow‚Äù Mean? In Elasticsearch:\ngreen: All primary and replica shards are assigned and active. yellow: All primary shards are active, but at least one replica shard is unassigned. red: At least one primary shard is missing ‚Üí critical! Why Yellow Happens on Single Nodes In single-node clusters, Elasticsearch cannot assign replica shards (because replicas must be on a different node). So any index with replicas will always be yellow unless:\nYou add more nodes (not ideal on a Raspberry Pi) Or: You disable replicas (number_of_replicas: 0) Step-by-Step: Diagnose Yellow Shards 1. List all yellow indices GET _cat/indices?v\u0026health=yellow 2. See why a shard is unassigned GET _cluster/allocation/explain 3. Inspect shard assignment of a specific index GET _cat/shards/.monitoring-beats-7-2025.08.06?v Example output:\nindex shard prirep state docs store ip node .monitoring-beats-7-2025.08.06 0 p STARTED 7790 5.9mb 127.0.0.1 mynode .monitoring-beats-7-2025.08.06 0 r UNASSIGNED ‚Üí The r (replica) is unassigned ‚Üí yellow status.\nHow to Fix It A. Fix an individual index Set replicas to zero:\nPUT .monitoring-beats-7-2025.08.06/_settings { \"index\" : { \"number_of_replicas\" : 0 } } This changes the index health from yellow to green.\nB. Automatically fix all yellow indices If you want to automate the fix, use this (Kibana Dev Tools):\nGET _cat/indices?health=yellow\u0026format=json Then for each index in the result:\nPOST \u003cyour_index\u003e/_settings { \"index\": { \"number_of_replicas\": 0 } } C. Prevent future yellow indices Disable replicas by default using an index template:\nPUT _template/no-replica-default { \"index_patterns\": [\"*\"], \"settings\": { \"number_of_replicas\": 0 } } \u003e ‚ö†Ô∏è This applies to all future indices. Only do this in single-node environments.\nConclusion Yellow indices aren‚Äôt dangerous by default ‚Äî they just mean you‚Äôre missing redundancy. In small environments, it‚Äôs perfectly safe to run with zero replicas.\nJust remember:\nMonitor your shard health Disable replicas if you only have one node Automate where you can Happy clustering!",
    "description": "Introduction If you‚Äôre running Elasticsearch on a single node ‚Äî like a Raspberry Pi or small lab setup ‚Äî you might notice some indices appear with a yellow health status.\nThis article explains what that means and how to fix it, especially in resource-constrained, single-node environments.\nWhat Does ‚ÄúYellow‚Äù Mean? In Elasticsearch:\ngreen: All primary and replica shards are assigned and active. yellow: All primary shards are active, but at least one replica shard is unassigned. red: At least one primary shard is missing ‚Üí critical! Why Yellow Happens on Single Nodes In single-node clusters, Elasticsearch cannot assign replica shards (because replicas must be on a different node). So any index with replicas will always be yellow unless:",
    "tags": [
      "Forensicwheels"
    ],
    "title": "Fixing Yellow Shards in Elasticsearch",
    "uri": "/posts/yellowshardsinelastic/index.html"
  },
  {
    "breadcrumb": "Welcome¬†\u003e¬†Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag - Forensicwheels",
    "uri": "/tags/forensicwheels/index.html"
  },
  {
    "breadcrumb": "Welcome",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/tags/index.html"
  },
  {
    "breadcrumb": "Welcome",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/categories/index.html"
  },
  {
    "breadcrumb": "Welcome¬†\u003e¬†Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag - Honeypot",
    "uri": "/tags/honeypot/index.html"
  },
  {
    "breadcrumb": "Welcome¬†\u003e¬†Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag - Threathunting",
    "uri": "/tags/threathunting/index.html"
  },
  {
    "breadcrumb": "Welcome¬†\u003e¬†Categories",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Category - Threathunting",
    "uri": "/categories/threathunting/index.html"
  },
  {
    "breadcrumb": "Welcome¬†\u003e¬†Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag - Visibility",
    "uri": "/tags/visibility/index.html"
  },
  {
    "breadcrumb": "Welcome¬†\u003e¬†Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag - Personal",
    "uri": "/tags/personal/index.html"
  },
  {
    "breadcrumb": "Welcome¬†\u003e¬†Categories",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Category - Personal",
    "uri": "/categories/personal/index.html"
  }
]
