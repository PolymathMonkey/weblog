var relearn_searchindex = [
  {
    "breadcrumb": "Welcome",
    "content": "Welcome to my technical blog and knowledge base!\nTopics üñ• Threathunting Tutorials üñ• OpenBSD Latest posts Threathunting I: Network setup 08.07.2025 Threat hunting II: SSH Honeypot setup 13.07.2025 Threathunting III: HTTP Honeypot develop and setup 13.08.2025 OpenBSD and Zen 07.07.2025 Adventures in threathunting 19.08.2025 Get in Touch Suggestions or feedback?\nContact me here or visit the project repository.\nYou can also subscribe via RSS.",
    "description": "Latest posts",
    "tags": [],
    "title": "Forensic wheels",
    "uri": "/posts/index.html"
  },
  {
    "breadcrumb": "",
    "content": "Welcome to my technical blog and knowledge base!\nTopics üñ• Threathunting Tutorials üñ• All things OpenBSD Latest posts Threathunting I: Network setup 08.07.2025 Threat hunting II: SSH Honeypot setup 13.07.2025 Threathunting III: HTTP Honeypot develop and setup 13.08.2025 OpenBSD and Zen 07.07.2025 Adventures in threathunting 19.08.2025 Get in Touch Suggestions or feedback?\nContact me here or visit the project repository.\nYou can also subscribe via RSS.",
    "description": "Latest posts",
    "tags": [],
    "title": "Welcome",
    "uri": "/index.html"
  },
  {
    "breadcrumb": "Welcome¬†\u003e¬†Forensic wheels",
    "content": "Introduction Why I Built a Home Lab for Threat Hunting üïµ Network Setup Topology, Hardware and Tools üõ† Firewall configurationüß± Switch configuration What I Learned Whats next Introduction This is a small series I wanted to start, where I write about my small threathunting setup and describe a little what I build and what I am doing with it.\nIn this part, I will describe the Network setup for my Environment, more about how I build the honeypots and the ELK Server I will describe in the follow up articles about threathunting.\nKeep in mind this is for Education and fun, no serious stuff going on here.\nWhy I Built a Home Lab for Threat Hunting üïµ The threat landscape is constantly evolving, with new attack vectors, tools, and tactics appearing almost daily.\nAnd to keep my skills current with real-world threats, I built a home lab dedicated to threat hunting. This environment allows me to safely observe attacks and develop detection and defense methods. I deployed web and shell honeypots, and collect real threat data in a controlled setting.\nIt‚Äôs a practical, hands-on way to explore the behavior of adversaries and its a lot of fun!\nNetwork Setup Topology, Hardware and Tools üõ† For the hardware setup, I kept things lightweight and affordable by using Raspberry Pi devices and open-source tools. The honeypot is based on the well-known Cowrie SSH honeypot and the honeyhttpd HTTP honeypot . It runs on a Raspberry Pi 4 with 8GB of RAM, hosted inside a Docker üê≥ container. On the honeypot host, Filebeat is running to ingest the Cowrie logs into the ELK stack.\nFor the ELK stack, I used a Raspberry Pi 5 with 16GB of RAM, running Debian. The ELK services are also containerized using Docker. The stack is based on the DShield-SIEM project, which I customized to better fit my needs. I‚Äôll dive deeper into those modifications and the ELK setup in a follow-up article.\nThe network topology is straightforward but deliberately segmented. The router is connected to a managed switch, which is responsible for handling VLAN separation. Both the honeypot and the ELK server are connected to this switch and are placed in an isolated VLAN (VLAN210). This VLAN is dedicated exclusively to threat hunting, ensuring that any potentially malicious traffic remains fully contained and cannot interfere with the rest of the home network.\nMy client system üíª is the only machine allowed to connect from outside the VLAN to both the ELK server and the honeypot. This connection is strictly for maintenance and administrative purposes. The ELK server is allowed to access the internet, primarily to pull threat intelligence data from external sources and security feeds.\nIn contrast, the honeypot is completely blocked from internet access, with the exception of SSH and HTTP traffic going in and out of it. These are the only services deliberately exposed to simulate vulnerable endpoints. Communication between the honeypot and the ELK server is allowed for log ingestion and analysis. However, I intend to introduce stricter controls on this internal traffic in the future to further reduce the attack surface.\nFirewall configurationüß± For the pf(1) configuration It was as always with UNIX fairly easy to get to work:\nmatch in quick log on egress proto tcp from any to any port 22 flags S/SA rdr-to $honeypot port 2222 match in quick log on egress proto tcp from any to any port 443 flags S/SA rdr-to $honeypot port 4433 This rule makes sure any incoming TCP connection attempt to port 22 (SSH) and port 443 (HTTPS) is immediately intercepted, logged, and transparently redirected to the $honeypot server listening on port 2222 or 4433 for HTTPS Traffic.\nSwitch configuration Here you can see my managed switch configuration. Port 5 (honeypot) is only assigned to VLAN210 like port 5 too, port 2 is the router it needs to talk into both networks and at port 1 is my workstation to access the theathunting environment.\nWhat I Learned Building and maintaining this lightweight honeypot and monitoring setup on Raspberry Pi devices has been an insightful experience. Here are some key takeaways:\nResource Efficiency: Raspberry Pis provide a surprisingly capable platform for running complex services like Cowrie honeypot and the ELK stack in Docker containers, keeping costs and power consumption low.\nNetwork Segmentation Matters: Isolating the honeypot and ELK server in a dedicated VLAN (VLAN210) effectively contains malicious traffic, protecting the rest of the home network from potential threats.\nControlled Access Is Crucial: Restricting external access to only authorized clients and limiting the honeypot‚Äôs internet connectivity reduces the attack surface while still enabling useful data collection.\nLogging and Data Collection: Using Filebeat to ship logs from the honeypot to the ELK stack provides real-time visibility into attacker behavior, which is essential for threat hunting and incident response.\nCustomization Pays Off: Adapting existing tools and SIEM projects (like DShield) to specific needs improves effectiveness and allows for tailored threat detection.\nFuture Improvements: There is always room to tighten internal communication rules and harden the setup further to minimize risk and improve operational security.\nThis project highlights the balance between practical constraints and security needs, demonstrating that even modest hardware can contribute significantly to threat intelligence and network defense.\nI drew inspiration for this setup from the DShield SIEM project by SANS and would like to express my gratitude for their valuable work.\nWhats next Next I had to build the ssh honeypot and the HTTP Honeypot, stay tuned for the follow up!\nFeedback and Comments",
    "description": "Introduction Why I Built a Home Lab for Threat Hunting üïµ Network Setup Topology, Hardware and Tools üõ† Firewall configurationüß± Switch configuration What I Learned Whats next Introduction This is a small series I wanted to start, where I write about my small threathunting setup and describe a little what I build and what I am doing with it.",
    "tags": [
      "Threathunting",
      "Honeypot",
      "Visibility"
    ],
    "title": "Threathunting I: Network setup",
    "uri": "/posts/threathuntingnet/index.html"
  },
  {
    "breadcrumb": "Welcome",
    "content": "About Hi, I‚Äôm Dirk ‚Äî a security engineer with a deep passion for skateboarding and digital forensics. I help my company protect networks and systems against evolving cybersecurity threats through a mix of technical expertise and continuous learning.\nSkateboarding is more than a hobby to me; it‚Äôs a source of creativity, freedom, and community. It shapes how I approach challenges ‚Äî with persistence, balance, and a mindset open to innovation.\nBeyond that, I‚Äôm an OpenBSD enthusiast. I‚Äôve built an OpenBSD-based router and threat-hunting infrastructure to stay ahead in cybersecurity. I appreciate OpenBSD for its simplicity, security, and elegance ‚Äî qualities I strive to bring to my work.\nI‚Äôm also a longtime Emacs user, relying on it daily for coding, writing, and organizing my thoughts. It‚Äôs part of how I stay productive and focused.\nIn cybersecurity, I‚Äôm committed to continuous growth and adapting to new challenges. When I‚Äôm not working on security projects, you‚Äôll find me skating or exploring new ideas inspired by Zen philosophy.\nYou can download my CV as a signed and encrypted PDF for authenticity and privacy. If you need the password to decrypt it, please send me an mail.\nStay tuned for updates on my journey as a security engineer, skateboarder, and lifelong learner.\nPublic Key (PGP) Key ID: 0xC2920C559CAD6CB Fingerprint: 40CA 727E 96D3 CC2D 8CBB 1540 0C29 20C5 59CA D6CB SHA-256 Hash:\nc7359e0e8bd69ed7cee3ea97453c10e327bfe2416822f54c6390efe72b0d6e7a Download public key",
    "description": "Short intro about myself",
    "tags": [
      "Forensicwheels",
      "Personal"
    ],
    "title": "About",
    "uri": "/about/index.html"
  },
  {
    "breadcrumb": "Welcome¬†\u003e¬†Forensic wheels",
    "content": "Introduction What is Cowrie? Why Podman over Docker? Preconditions / System setup Ubuntu Installed on Raspberry Pi 4+ System Fully Updated Podman installed and working: VLAN Tagging Configured on Network Interface Setup environment, install cowrie as container and adjust configuration üêß Create a Dedicated User for Cowrie (No Login Shell) üê≥ Pull and Configure Cowrie with Podman üõ† cowrie.cfg ‚Äì Basic Overview üöÄ Run Cowrie Container as ‚Äòcowrie‚Äô User üéØ Operating the Honeypot üîÑ Automatically Restart Cowrie Podman Container with systemd üîí Security Notes Log Forwarding with Filebeat üì¶ Install Filebeat on Ubuntu ‚öô Configure and test Filebeat üöÄ Start and Enable Filebeat üéØ TL;DR ‚Äì What Did We Just Do? Whats next Introduction This post provides a brief walkthrough of how to deploy a lightweight, containerized SSH honeypot using Cowrie and Podman, with the goal of capturing and analyzing malicious activity as part of my threat hunting strategy.\nWhat is Cowrie? Cowrie is an interactive SSH and Telnet honeypot designed to emulate a real system, capturing attacker behavior in a controlled environment. It allows defenders and researchers to observe malicious activity without exposing actual infrastructure.\nKey capabilities of Cowrie include\nFull session logging: Records all commands entered by the attacker, along with input/output streams and timing data. Sessions can be saved as plaintext or in formats suitable for replay.\nFake file system and shell environment: Emulates a basic Linux shell with a user-modifiable file system. Attackers can navigate directories, read/write fake files, or attempt to download/upload payloads.\nCommand emulation: Supports a large set of common Unix commands (`ls`, `cat`, `wget`, etc.), allowing attackers to interact naturally, as if on a real system. And can be extended with more commands\nCredential logging: Captures usernames and passwords used in brute-force login attempts or interactive logins.\nFile download capture: Logs and optionally stores any files attackers attempt to retrieve via `wget`, `curl`, or similar tools.\nJSON-formatted logging and integration‚Äôs: Outputs structured logs that are easy to parse and ingest into systems like ELK, Splunk, or custom analysis pipelines.\nCowrie is widely used in research, threat intelligence, and proactive defense efforts to gather Indicators of Compromise (IOCs) and understand attacker tactics,techniques, and procedures (TTPs).\nWhy Podman over Docker? Podman offers several advantages over Docker, particularly in terms of security and system integration. It supports rootless containers, allowing users to run containers without elevated privileges, which reduces the attack surface.\nPodman is daemon-less, integrating more seamlessly with systemd and existing Linux workflows. Additionally, Podman is fully compatible with the Open Container Initiative (OCI) standards, ensuring interoperability and flexibility across container ecosystems.\nPreconditions / System setup Before I proceed with the cowrie setup, I made sure the following preconditions are met:\nUbuntu Installed on Raspberry Pi 4+ I am using a Raspberry Pi 4+ running Ubuntu\nSystem Fully Updated After installation, I made sure system is up to date:\nsudo apt update \u0026\u0026 sudo apt upgrade -y Podman installed and working: # Ubuntu 20.10 and newer sudo apt-get -y install podman Run the Hello World Container.In this moment I did not had the cowrie user yet setup so I used my system user to test\npodman run hello-world Trying to pull docker.io/library/hello-world:latest... ... Hello from Docker! This message shows that your installation appears to be working correctly. tho sometimes the pulling fails like that then I had to put `docker.io` in front of the container name like:\npodman run docker.io/hello-world then it would work for sure.\nVLAN Tagging Configured on Network Interface In my network setup for threathunting the honeypot requires VLAN tagging to configured to reachable from the outside, VLAN210 is my restricted Network. Therefore i needed to configure the vlan using nmcli so it‚Äôs persistent across reboots.\nExample: Create a VLAN interface (e.g., VLAN ID 210 on main if) sudo nmcli con add type vlan con-name vlan210 dev mainif id 210 ip4 192.168.210.3/24 gw4 192.168.210.1 sudo nmcli con up vlan210 con-name vlan210: Name of the new VLAN connection. dev mainif: Physical interface to tag. id 210: VLAN ID. ip4, gw4: Optional IP and gateway assignment. This will persist the configuration and activate the VLAN interface immediately. Next I moved on to Install the honeypot.\nSetup environment, install cowrie as container and adjust configuration üêß Create a Dedicated User for Cowrie (No Login Shell) Running the Podman container under a dedicated system user with no login shell is a recommended security best practice. Reasons include:\nPrivilege Separation: Isolates the container from other system processes and users, limiting the potential impact of a compromise.\nReduced Attack Surface: The user has no login shell (e.g., /usr/sbin/nologin), meaning it can‚Äôt be used to log into the system interactively.\nAuditing \u0026 Logging: Helps distinguish container activity in system logs and process lists, making monitoring easier.\nLeast Privilege Principle: The user has only the permissions necessary to run the container ‚Äî nothing more.\n1. Create the ‚Äòcowrie‚Äô user (no home directory, no login shell)\nsudo useradd --system --no-create-home --shell /usr/sbin/nologin cowrie 2. Create necessary directories and set ownership\nsudo mkdir -p /opt/cowrie/etc sudo mkdir -p /opt/cowrie/var sudo chown -R cowrie:cowrie /opt/cowrie üê≥ Pull and Configure Cowrie with Podman 3. As the cowrie user, pull the container image\nsudo -u cowrie podman pull docker.io/cowrie/cowrie 4. Copy default config file into persistent volume\nsudo -u cowrie podman run --rm cowrie/cowrie \\ cat /cowrie/cowrie-git/etc/cowrie.cfg.dist \u003e /opt/cowrie/etc/cowrie.cfg üõ† cowrie.cfg ‚Äì Basic Overview The `cowrie.cfg` file is the main configuration for Cowrie, the SSH/Telnet honeypot we use. It uses INI-style syntax and is divided into sections. Each section begins with a header like [section_name].\nüìÅ Key Sections \u0026 Settings\n[ssh] / [telnet]\nEnable or disable SSH/Telnet and set the port to listen on:: enabled = true listen_port = 2222 [honeypot]\nSet honeypot host name and logpath properties:\nhostname = cowrie-host # Directory where to save log files in. log_path = var/log/cowrie Define login behavior:\nauth_class = AuthRandom auth_class_parameters = 1, 5, 10 I use AuthRandom here which causes to allow access after ‚Äúrandint(2,5)‚Äù attempts. This means the threat actor will fail with some logins and some will be logged in immediately.\n[output_jsonlog]\nConfigure logging and output plugins: [output_jsonlog] enabled = true logfile = ${honeypot:log_path}/cowrie.json epoch_timestamp = false This sets the default log location in the file-system, this is important so that file beat later can pickup on the juicy honeypot log files. This is the whole configuration needed to run the honeypot.\nüìå Notes\nRestart Cowrie after configuration changes. The configuration can be split across multiple `.cfg` files in `cowrie.cfg.d/` for modular setup. üöÄ Run Cowrie Container as ‚Äòcowrie‚Äô User Once I had created the dedicated system user (see earlier section), I was able to run the Cowrie container with Podman using sudo -u and a secure UID mapping.\nStep-by-Step Command explanation sudo -u cowrie podman run -d --name cowrie \\ --uidmap 0:$(id -u cowrie):1 \\ -v /opt/cowrie/etc:/cowrie/cowrie-git/etc:Z \\ -v /opt/cowrie/var:/cowrie/cowrie-git/var:Z \\ -p 2222:2222 \\ cowrie/cowrie Explanation sudo -u cowrie: Runs the Podman command as the unprivileged cowrie user. --uidmap 0:$(id -u cowrie):1: Maps root (UID 0) inside the container to the cowrie UID on the host. -v /opt/cowrie/etc and /opt/cowrie/var: Mounts configuration and data volumes from the host with `:Z` to apply correct SELinux labels (optional on systems without SELinux). -p 2222:2222: Forwards port 2222 from host to container (Cowrie‚Äôs SSH honeypot port). cowrie/cowrie: The container image name (use latest or specific tag as needed). Benefits: Container runs as non-root on the host: Even if a process inside the container thinks it‚Äôs root, it‚Äôs actually limited to the unprivileged cowrie user outside the container.\nEnhanced security: If the container is compromised, the attacker only gets access as the cowrie user ‚Äî not real root.\nAvoids root-equivalent risks: Prevents privilege escalation or access to sensitive host files and devices.\nüéØ Operating the Honeypot View logs I think to know how to debug the container is important so we start first with the logs:\nsudo -u cowrie podman logs -f cowrie ...snip... [HoneyPotSSHTransport,14,10.0.2.100] Closing TTY Log: var/lib/cowrie/tty/e52d9c508c502347344d8c07ad91cbd6068afc75ff6292f062a09ca381c89e71 after 0.8 seconds [cowrie.ssh.connection.CowrieSSHConnection#info] sending close 0 [cowrie.ssh.session.HoneyPotSSHSession#info] remote close [HoneyPotSSHTransport,14,10.0.2.100] Got remote error, code 11 reason: b'disconnected by user' [HoneyPotSSHTransport,14,10.0.2.100] avatar root logging out [cowrie.ssh.transport.HoneyPotSSHTransport#info] connection lost [HoneyPotSSHTransport,14,10.0.2.100] Connection lost after 2.8 seconds ...snip... Restart container If things go left just restart that thing:\nsudo -u cowrie podman restart cowrie In the logs you can see that cowrie is running and accepting SSH connections:\n...snip... [-] CowrieSSHFactory starting on 2222 [cowrie.ssh.factory.CowrieSSHFactory#info] Starting factory \u003ccowrie.ssh.factory.CowrieSSHFactory object at 0x7fb66f26d0\u003e [-] Ready to accept SSH connections ...snip... When the log says ‚ÄúReady to accept SSH connections‚Äù I tested if I could login:\nssh 192.168.210.3 -p 2222 -l root root@192.168.210.3 password: The programs included with the Debian GNU/Linux system are free software; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. root@svr04:~# uname -a Linux svr04 3.2.0-4-amd64 #1 SMP Debian 3.2.68-1+deb7u1 x86_64 GNU/Linux root@svr04:~# Stop container Nothing special here:\nsudo -u cowrie podman stop cowrie üîÑ Automatically Restart Cowrie Podman Container with systemd To keep your Cowrie container running reliably and restart it if it stops, use a systemd service with restart policies.\nStep 1: Generate a systemd Service File Create `/etc/systemd/system/cowrie-container.service` with the following content:\n[Unit] Description=Cowrie Honeypot Podman Container After=network.target [Service] User=cowrie Group=cowrie Restart=on-failure RestartSec=10s ExecStart=/usr/bin/podman run -d --name cowrie \\ --uidmap 0:$(id -u cowrie):1 \\ -v /opt/cowrie/etc:/cowrie/cowrie-git/etc:Z \\ -v /opt/cowrie/var:/cowrie/cowrie-git/var:Z \\ -p 2222:2222 \\ cowrie/cowrie ExecStop=/usr/bin/podman stop -t 10 cowrie ExecStopPost=/usr/bin/podman rm cowrie ExecReload=/usr/bin/podman restart cowrie TimeoutStartSec=120 [Install] WantedBy=multi-user.target The `‚Äìrestart-policy=on-failure` makes systemd restart the container if it exits with a failure. Step 2: Enable the Service sudo systemctl daemon-reload sudo systemctl enable --now container-cowrie.service Step 3: (Optional) Add a Health Check Script To detect if Cowrie stops accepting connections even if the container is still running, create a health check script running as cowrie:\nCreate `/usr/local/bin/check_cowrie.sh`:\n#!/bin/bash if ! nc -z localhost 2222; then echo \"Cowrie not responding, restarting container\" /usr/bin/podman restart cowrie /usr/local/bin/pushover.sh \"Cowrie was restarted!\" fi This restarts the service and sends out a notification via pushover.\nMake it executable:\nsudo chmod +x /usr/local/bin/check_cowrie.sh sudo chown cowrie:cowrie /usr/local/bin/check_cowrie.sh Create systemd service `/etc/systemd/system/check_cowrie.service`:\n[Unit] Description=Check Cowrie honeypot health [Service] User=cowrie Group=cowrie Type=oneshot ExecStart=/usr/local/bin/check_cowrie.sh Create systemd timer `/etc/systemd/system/check_cowrie.timer`:\n[Unit] Description=Run Cowrie health check every minute [Timer] OnBootSec=1min OnUnitActiveSec=1min Unit=check_cowrie.service [Install] WantedBy=timers.target Enable and start the timer:\nsudo systemctl daemon-reload sudo systemctl enable --now check_cowrie.timer Summary Used Podman‚Äôs systemd integration for automatic restart on container failure. Added a health check timer to detect if Cowrie stops accepting connections and restart proactively. üîí Security Notes The `cowrie` user has no login shell (`/usr/sbin/no login`)\nRunning Cowrie isolated via Podman increases containment\nAll files are owned by `cowrie`, no root access required for normal operation\nLog Forwarding with Filebeat üì¶ Install Filebeat on Ubuntu 1. Add Elastic‚Äôs GPG key and repository\ncurl -fsSL https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo gpg --dearmor -o /usr/share/keyrings/elastic.gpg echo \"deb [signed-by=/usr/share/keyrings/elastic.gpg] https://artifacts.elastic.co/packages/8.x/apt stable main\" | \\ sudo tee /etc/apt/sources.list.d/elastic-8.x.list 2. Update APT and install Filebeat\nsudo apt update sudo apt install filebeat ‚öô Configure and test Filebeat 3. Edit Filebeat config\nsudo mg /etc/filebeat/filebeat.yml The filebeat config is straight forward. You have to write a filebeat.input block which contains the path where the logfiles are you need to ingest. And at the end the log-destination (logstash) so that filebeat knows where to send the logs to:\nfilebeat.inputs: - type: log enabled: true paths: - /opt/cowrie/var/log/cowrie/cowrie.json json.keys_under_root: true json.add_error_key: true fields: source: cowrie fields_under_root: true output.logstash: hosts: [\"192.168.123.5:5044\"] 4. (Optional) Test Filebeat config\nsudo filebeat test config üöÄ Start and Enable Filebeat 5. Enable and start Filebeat\nsudo systemctl enable filebeat sudo systemctl daemon-reload sudo systemctl start filebeat 6. Check Filebeat status and logs\nsudo systemctl status filebeat sudo journalctl -u filebeat -f üéØ TL;DR ‚Äì What Did We Just Do? 1. We deployed Cowrie like pros.\nRan it safely in a Podman container under a non-login user. No mess, no root, no regrets. 2. Logs? Sorted.\nFilebeat scooped up Cowrie‚Äôs logs and shipped them to Elasticsearch. Now we can actually see who‚Äôs knocking on the honeypot door. 3. Everything‚Äôs persistent.\nConfigs and logs live outside the container. Cowrie forgets nothing‚Äîeven after a reboot. 4. Setup is clean and modular.\nEach part (Cowrie, Filebeat, Elasticsearch) does its job. Break one, fix one‚Äîno domino disasters. 5. It‚Äôs nerdy, useful, and kinda fun.\nNow I built a mini threat intel system. Now I can sit back, sip coffee, and watch the kiddies play. Whats next Next I had to build the HTTP honeypot, stay tuned for the follow up!\nFeedback and Comments",
    "description": "Introduction What is Cowrie? Why Podman over Docker? Preconditions / System setup Ubuntu Installed on Raspberry Pi 4+ System Fully Updated Podman installed and working: VLAN Tagging Configured on Network Interface Setup environment, install cowrie as container and adjust configuration üêß Create a Dedicated User for Cowrie (No Login Shell) üê≥ Pull and Configure Cowrie with Podman üõ† cowrie.cfg ‚Äì Basic Overview üöÄ Run Cowrie Container as ‚Äòcowrie‚Äô User üéØ Operating the Honeypot üîÑ Automatically Restart Cowrie Podman Container with systemd üîí Security Notes Log Forwarding with Filebeat üì¶ Install Filebeat on Ubuntu ‚öô Configure and test Filebeat üöÄ Start and Enable Filebeat üéØ TL;DR ‚Äì What Did We Just Do? Whats next Introduction This post provides a brief walkthrough of how to deploy a lightweight, containerized SSH honeypot using Cowrie and Podman, with the goal of capturing and analyzing malicious activity as part of my threat hunting strategy.",
    "tags": [
      "Threathunting",
      "Honeypot"
    ],
    "title": "Threat hunting II: SSH Honeypot setup",
    "uri": "/posts/theathuntinghoneypot/index.html"
  },
  {
    "breadcrumb": "Welcome¬†\u003e¬†Forensic wheels",
    "content": "Introduction Brief overview of the use case Setting up HoneyPot HTTPD for Web Data Ingestion and adjust code for our needs Containerizing the application to run inside docker üöÄ Code adjustments for our environment üìù Conclusion Introduction Brief overview of the use case I recently set out to ingest web traffic data into my SIEM solution, which requires data to be ingested in a specific format. After researching various options, I sought an easy-to-use solution that could integrate with our existing Elasticsearch setup. One tool that caught my attention was HoneyPot HTTPD.\nAs I researched potential solutions, I realized that many of them required manual configuration and scripting to ingest web data into Elasticsearch. However, HoneyPot HTTPD offered a simple and elegant way to do so through its built-in ingestion feature. This was especially appealing since I wanted to integrate the web traffic data with our existing SIEM setup that utilized Elasticsearch.\nIn particular, I needed a tool that could collect web traffic data and forward it to a centralized location for analysis and processing. Honeypot HTTPD‚Äôs ability to ingest web data into Elasticsearch made it an attractive choice, as it would allow me to leverage our existing Elasticsearch infrastructure and integrate the data with our SIEM solution seamlessly.\nWith this in mind, I set out to explore how to use HoneyPot HTTPD to ingest web traffic data into Elasticsearch. In the following sections, I‚Äôll walk you through the steps I took to configure HoneyPot HTTPD for ingestion, including the Dockerfile used to build the container and any additional configuration settings required.\nSetting up HoneyPot HTTPD for Web Data Ingestion and adjust code for our needs Containerizing the application to run inside docker Creating a Dockerfile\nI started by creating a Dockerfile that would build the HoneHTTPD image. The Dockerfile included the following instructions:\n# Use python base image FROM python:3 # Set environment ARG APP_NAME=honeyhttpd ENV APP_NAME=${APP_NAME} ARG USER_ID=\"10001\" ARG GROUP_ID=\"app\" ARG HOME=\"/app\" ENV HOME=${HOME} # Create user and environment RUN groupadd --gid ${USER_ID} ${GROUP_ID} \u0026\u0026 \\ useradd --create-home --uid ${USER_ID} --gid ${GROUP_ID} --home-dir /app ${GROUP_ID} # Install dependencies RUN apt-get update \u0026\u0026 \\ apt-get install -y --no-install-recommends \\ file \\ gcc \\ libwww-perl curl unzip \u0026\u0026 \\ apt-get autoremove -y \u0026\u0026 \\ apt-get clean # Set workdir WORKDIR ${HOME} # Copy config files and certs into container COPY ./requirements.txt . COPY ./config.json . COPY ./server*.pem . COPY ./ca.crt . COPY honeyhttpd logs servers util . COPY start.py . # Upgrade python packages and install dependencies RUN pip3 install --upgrade pip RUN pip3 install virtualenv RUN python3 -m virtualenv ${HOME} \u0026\u0026 \\ virtualenv ${HOME} RUN pip3 install --no-cache-dir --upgrade pip setuptools wheel elasticsearch==8.13.0 \u0026\u0026 \\ pip3 install --no-cache-dir --upgrade -r ./requirements.txt \u0026\u0026 pip3 install -r ./requirements.txt ADD . ${HOME} # Remove compilers RUN apt-get remove gcc --purge -y # Drop root and change ownership of the application folder to the user RUN chown -R ${USER_ID}:${GROUP_ID} ${HOME} USER ${USER_ID} # Expose Honeypot ports to outside world EXPOSE 8443:8443 # run cowrie with config CMD [\"python3\", \"start.py\", \"--config\", \"config.json\"] In this Dockerfile, I:\nUsed the official Ubuntu image as the base image Installed necessary dependencies, including Python and pip Installed the required packages, including HoneyPot HTTPD Set the working directory to /usr/local/bin to run the application from Exposed port 80 for HTTP traffic Copied the configuration file (config.yaml) into the container Specified the command to run HoneyPot HTTPD with the -c option, which points to the configuration file Building and Running the Container\nOnce I had created the Dockerfile, I built the image by running the following command:\nsudo docker build -t honeyhttpd . This command told Docker to create an image with the tag honeyhttpd using the instructions in the Dockerfile.To run the container, I used the following command:\nsudo docker run --hostname honeyhttpd -p 8443:8443 honeyhttpd This command started a new container from the honeyhttpd image and mapped port 8443 on the host machine to the port 8443 in the container.\nConfiguring the Container\nTo configure the honeypot, I updated the config.yaml file to point to my Elasticsearch instance. Here‚Äôs an example of what the configuration file might look like:\n\"loggers\": { \"ElasticSearchLogger\": { \"active\": true, \"config\": { \"server\": \"https://192.168.210.95:9200\", \"verify_certs\": true, \"username\": \"elastic\", \"password\": \"SecretPassword\", \"index\": \"cowrie.webhoneypot\", } } the server config itself is quite simplistic:\n\"servers\" : [ {\"handler\": \"ApachePasswordServer\", \"mode\": \"https\", \"port\": 8443, \"domain\": \"cooldomain.com\", \"timeout\": 10, \"cert_path\": \"server_cert.pem\", \"key_path\": \"server_key.pem\"}, ], \"user\": \"nobody\", \"group\": \"nogroup\" } This configuration told HoneyPot HTTPD to forward web traffic data to my Elasticsearch instance, where it could be processed and stored.\nFor the cert_path and key_path we earlier copied the self signed cert and key to the container.\nWith the container running and configured, I was now ready to test HoneyPot HTTPD‚Äôs ability to ingest web traffic data into Elasticsearch.\nWhich I did with just opening https://honeypot.home.arpa:8443 in my webbrowser. Which gave me the htpasswd auth prompt.\nüöÄ Code adjustments for our environment I started from the original `ApachePasswordServer` in honeyhttpd, which was fairly minimal‚Äîit simply responded with a 401 on selected paths and captured credentials in a rudimentary way. I overhauled it to better structure logging, extract metadata, and sanitize inputs before sending logs to Elasticsearch.\nBelow, I explain each change with commentary.\nüîê Improvements in `ApachePasswordServer.py`: Credential Logging and Header Parsing This update significantly extends the functionality of `ApachePasswordServer.py`. It builds on the original honeyhttpd implementation by enhancing its ability to simulate Basic Authentication, extract and decode credentials from the `Authorization` header, and log structured metadata about each HTTP request and response.\nIt now integrates tightly with an `ElasticSearchLogger`, providing enriched, sanitized logs for further analysis or visualization. Custom helper functions ensure safe parsing, while connection and client metadata offer greater context to the captured events.\nüìä Summary of Changes\n2 files changed: `ApachePasswordServer.py` and `Elasticsearchlogger.py` Key improvements: Simulation of Basic Auth (401 challenge on sensitive paths) Credential extraction and decoding from `Authorization` header Connection metadata collection (IP, port, useragent etc.) Header parsing with case-insensitive lookup Structured request and response logging Integration with `ElasticSearchLogger` Safer JSON serialization and error handling Here I describe how I extended the honeypot server to improve credential logging and integrate with Elasticsearch for structured logging.\nStarting from a basic server that simply issued 401 responses, I added features to parse HTTP requests, decode Basic Auth headers, and enrich logs with request and connection metadata. This makes the server far more useful for DFIR research and threat hunting.\nOriginal baseline from (for reference) Big thanks to the great ground wrok from bocajspear1 over at github with the honeyHTTPD Server. That way I did not had to write all from scratch. But I still had to make some improvements in order to use the honeypot in my Environment.\nfrom servers.ApacheServer import ApacheServer import honeyhttpd.lib.encode as encode class ApachePasswordServer(ApacheServer): def on_request(self, handler): return None, None def on_GET(self, path, headers): if path == \"/\" or path == \"/index.php\" or path == \"/admin\": return 401, [], \"Basic realm=\\\"Secure Area\\\"\" return 404, [], \"\" def on_POST(self, path, headers, post_data): return 404, [], \"\" def on_error(self, code, headers, message): return code, [(\"Connection\", \"close\"), (\"Content-Type\", \"text/html; charset=iso-8859-1\")], message def on_complete(self, client, code, req_headers, res_headers, request, response): extra = {} for header in req_headers: if header[0].lower() == \"authorization\": auth_split = header[1].split(\" \") if len(auth_split) \u003e 1: auth_data = auth_split[1] extra['creds'] = encode.decode_base64(auth_data) self.log(client, request, response, extra) def default_headers(self): return [] üÜï Auto-Injection of `ElasticSearchLogger` in `_init_()` To ensure consistent structured logging, `ElasticSearchLogger` is now injected into the logger stack if not already present.\n+ if loggers is None: + loggers = [] + if not any(isinstance(logger, ElasticSearchLogger) for logger in loggers): + loggers.append(ElasticSearchLogger()) This avoids missing logs if the user forgets to pass a logger during instantiation.\nüîê New GET Handler Simulates Apache Basic Auth Challenge The server now returns `401 Unauthorized` and prompts for credentials on common admin paths.\n+ def on_GET(self, path, headers): + if path in [\"/\", \"/index.php\", \"/admin\"]: + return 401, [], 'Basic realm=\"Secure Area\"' + return 404, [], \"\" This turns the honeypot into a credential trap for automated brute-forcers and scanners.\nüß∞ New Helper Functions for Header Parsing and Auth Decoding Two utility functions were introduced:\n`parse_to_json()` transforms header tuples into a JSON dictionary. `decode_basic_auth()` decodes Base64 credentials and validates them. def parse_to_json(data): return json.dumps({key: value for key, value in data}) def decode_basic_auth(b64_string): try: decoded_bytes = base64.b64decode(b64_string, validate=True) decoded_str = decoded_bytes.decode('utf-8') if ':' in decoded_str: return decoded_str else: return \"[invalid format: missing colon]\" except Exception as e: return f\"[decode error: {e}]\" These enable safe and consistent parsing for incoming HTTP headers.\nüì¶ Structured Request Parsing \u0026 Credential Extraction in `on_complete()` The `on_complete()` method has been completely reworked to:\nParse the HTTP request line Convert headers to a JSON object Extract relevant metadata and credentials Store all data in `req_dict`, passed to the logger - extra = {} + req_dict = {} ... + lines = request.split('\\n') + first_line = lines[0].strip() + parts = first_line.split() + requested_url = parts[1] if len(parts) \u003e 1 else \"\" + method = parts[0] if len(parts) \u003e 0 else \"\" + req_dict['request_body'] = requested_url + req_dict['method'] = method + req_dict['code'] = code + + try: + req_output = parse_to_json(req_headers) + parsed_req = json.loads(req_output) + except Exception as e: + parsed_req = {} + + for key in ['Host', 'User-Agent', 'Accept', 'Accept-Language', + 'Accept-Encoding', 'Authorization']: + req_dict[key] = parsed_req.get(key, '') + + auth = parsed_req.get('Authorization', '') + if auth.startswith(\"Basic \"): + try: + auth_data = auth.split(\" \", 1)[1] + decoded_creds = encode.decode_base64(auth_data) + req_dict['creds'] = decoded_creds + except Exception as e: + req_dict['creds'] = f\"[decode error: {e}]\" This prepares your logs to include useful hunting metadata for later analysis.\nüåê Enriched Connection Metadata Logging Additional context is logged to `req_dict`, including:\nRemote IP and port SSL usage Listening port HTTP response code Response headers + remote_ip = client[0] if isinstance(client, tuple) else '' + remote_port = client[1] if isinstance(client, tuple) else '' + is_ssl = getattr(self, 'is_ssl', False) + port = getattr(self, 'port', '8843') + + req_dict['remote_ip'] = remote_ip + req_dict['remote_port'] = remote_port + req_dict['is_ssl'] = is_ssl + req_dict['port'] = port + req_dict['response_headers'] = res_dict + + self.log(client, request, response, res_dict, req_dict) This provides rich forensic data for Elasticsearch or Splunk pipelines.\nüîë Highlights üÜï Auto-injection of `ElasticSearchLogger` Ensures logs are never silently dropped, even if no logger is passed explicitly.\nüîê Basic Auth Simulation with 401 Challenge Returns `401 Unauthorized` on suspicious paths to bait scanners.\nüß∞ Safe Parsing \u0026 Decoding with Helpers New functions `parse_to_json()` and `decode_basic_auth()` added for reliability.\nüì¶ Structured Logging in `on_complete()` Fully rewritten to extract metadata, decode credentials, and prepare logs.\nüåê Rich Connection Context Logs IP, port, SSL usage, and full response headers for correlation.\nüß† Use Case These changes upgrade `ApachePasswordServer.py` from a toy honeypot to a serious data source for threat hunting. It can now be safely deployed in research environments, logging attack metadata in structured formats ideal for analysis pipelines like Elasticsearch + Kibana or Splunk.\nüìù Conclusion üîë Key points about using HoneyPotHTTPD to ingest web data into Elasticsearch This article detailed how I enhanced `ApachePasswordServer.py` to make the simple honeypot into a powerful tool for capturing attacker behavior. By simulating Apache Basic Authentication challenges and extracting credentials from incoming requests, I enabled my honeypot effectively to bait malicious actors.\nStructured parsing of HTTP requests and responses combined with integration into `ElasticSearchLogger` allows me to generate rich, queryable logs, complete with client metadata, HTTP headers, and decoded credentials.\nThis setup not only captures raw data but also organizes it in a way that facilitates downstream analysis using Elasticsearch or similar log management platforms.\nüí° Final thoughts on the value of this setup for your organization‚Äôs threat hunting or security operations.\nDeploying this enhanced honeypot within your environment equips your security team with detailed, actionable insights into attacker tactics and techniques. The ability to collect and analyze credential attempts and associated metadatah improves detection fidelity and supports incident response efforts.\nBy bridging the gap between mere detection and detailed forensic logging, this solution empowers proactive threat hunting and accelerates the identification of emerging attack patterns. Integrating it into your security operations stack can thus significantly boost your organization‚Äôs defensive capabilities.\nTODO - Extensivce testing of the honeypot, there will be an article coming up how to do automated honeypot testing with Zap proxy, stay tuned!",
    "description": "Introduction Brief overview of the use case Setting up HoneyPot HTTPD for Web Data Ingestion and adjust code for our needs Containerizing the application to run inside docker üöÄ Code adjustments for our environment üìù Conclusion Introduction Brief overview of the use case I recently set out to ingest web traffic data into my SIEM solution, which requires data to be ingested in a specific format. After researching various options, I sought an easy-to-use solution that could integrate with our existing Elasticsearch setup. One tool that caught my attention was HoneyPot HTTPD.",
    "tags": [
      "Threathunting",
      "Honeypot"
    ],
    "title": "Threathunting III: HTTP Honeypot develop and setup",
    "uri": "/posts/honeyhttpd/index.html"
  },
  {
    "breadcrumb": "Welcome¬†\u003e¬†Forensic wheels",
    "content": "About As someone who is passionate about security and has an interest in Unix operating systems, OpenBSD particularly captivates due to its dedication to security, stability, and simplicity. In comparison to other OSes, what sets OpenBSD apart? And how do these principles align with my journey through Zen meditation?\nAt first glance, OpenBSD and Zen may appear to be vastly disparate concepts - one being a potent operating system, while the other is a spiritual practice originating from ancient China. However, as I delved deeper into both realms, I uncovered some fascinating similarities.\nSimplicity and Clarity In Zen, simplicity is key to achieving inner clarity and balance. By stripping away unnecessary complexity, OpenBSD aims to create a stable and secure foundation for users. Similarly, in meditation, simplicity helps to quiet the mind and focus on the present moment. This alignment between OpenBSD‚Äôs philosophy and Zen practices extends to their shared emphasis on mindfulness and deliberate decision-making, fostering an environment of security and tranquility in both realms.\nAttention to Detail Both OpenBSD and Zen underscore the significance of attending to detail. In software development, this entails meticulously crafting each line of code to guarantee stability and security. In Zen practice, it involves paying close attention to one‚Äôs breath, posture, and mental state to attain a state of mindfulness. By zeroing in on these details, both OpenBSD and Zen strive for perfection.\nThe Power of Consistency OpenBSD‚Äôs dedication to consistency is manifested in its codebase, where each code change undergoes a thorough code review process. Consistency holds equal importance in Zen practice, as it fosters a sense of routine and stability. By cultivating a consistent daily meditation practice, I have discovered that consistency is instrumental in making progress on my spiritual journey. OpenBSD‚Äôs emphasis on consistency mirrors the principles of Zen, emphasizing the value of diligence and discipline in both domains.\nThe Beauty of Imperfection Finally, both OpenBSD and Zen acknowledge the elegance in imperfection. In software development, imperfections can often be rectified or lessened through meticulous design and testing. In Zen practice, imperfections are perceived as avenues for growth and self-awareness.\nBy acknowledging our imperfections, we can nurture humility and compassion. As I progress in my journey with OpenBSD and Zen, I am consistently struck by the ways in which these two seemingly unrelated realms intersect. By embracing simplicity, attention to detail, consistency, and the beauty of imperfection, both OpenBSD and Zen provide unique perspectives on the nature of software development and personal growth. Stay tuned for further insights from my exploration in the realm of security!\nFeedback and Comments",
    "description": "About As someone who is passionate about security and has an interest in Unix operating systems, OpenBSD particularly captivates due to its dedication to security, stability, and simplicity. In comparison to other OSes, what sets OpenBSD apart? And how do these principles align with my journey through Zen meditation?\nAt first glance, OpenBSD and Zen may appear to be vastly disparate concepts - one being a potent operating system, while the other is a spiritual practice originating from ancient China. However, as I delved deeper into both realms, I uncovered some fascinating similarities.",
    "tags": [
      "Forensicwheels",
      "Openbsd",
      "Zen"
    ],
    "title": "OpenBSD and Zen",
    "uri": "/posts/openbsdzen/index.html"
  },
  {
    "breadcrumb": "Welcome¬†\u003e¬†Forensic wheels",
    "content": "DONE Threathunting I: Network setup @threathuntinghoneypotvisibility Introduction This is a small series I wanted to start, where I write about my small threathunting setup and describe a little what I build and what I am doing with it.\nIn this part, I will describe the Network setup for my Environment, more about how I build the honeypots and the ELK Server I will describe in the follow up articles about threathunting.\nKeep in mind this is for Education and fun, no serious stuff going on here.\nWhy I Built a Home Lab for Threat Hunting üïµ The threat landscape is constantly evolving, with new attack vectors, tools, and tactics appearing almost daily.\nAnd to keep my skills current with real-world threats, I built a home lab dedicated to threat hunting. This environment allows me to safely observe attacks and develop detection and defense methods. I deployed web and shell honeypots, and collect real threat data in a controlled setting.\nIt‚Äôs a practical, hands-on way to explore the behavior of adversaries and its a lot of fun!\nNetwork Setup Topology, Hardware and Tools üõ† For the hardware setup, I kept things lightweight and affordable by using Raspberry Pi devices and open-source tools. The honeypot is based on the well-known Cowrie SSH honeypot and the honeyhttpd HTTP honeypot . It runs on a Raspberry Pi 4 with 8GB of RAM, hosted inside a Docker üê≥ container. On the honeypot host, Filebeat is running to ingest the Cowrie logs into the ELK stack.\nFor the ELK stack, I used a Raspberry Pi 5 with 16GB of RAM, running Debian. The ELK services are also containerized using Docker. The stack is based on the DShield-SIEM project, which I customized to better fit my needs. I‚Äôll dive deeper into those modifications and the ELK setup in a follow-up article.\nThe network topology is straightforward but deliberately segmented. The router is connected to a managed switch, which is responsible for handling VLAN separation. Both the honeypot and the ELK server are connected to this switch and are placed in an isolated VLAN (VLAN210). This VLAN is dedicated exclusively to threat hunting, ensuring that any potentially malicious traffic remains fully contained and cannot interfere with the rest of the home network.\nMy client system üíª is the only machine allowed to connect from outside the VLAN to both the ELK server and the honeypot. This connection is strictly for maintenance and administrative purposes. The ELK server is allowed to access the internet, primarily to pull threat intelligence data from external sources and security feeds.\nIn contrast, the honeypot is completely blocked from internet access, with the exception of SSH and HTTP traffic going in and out of it. These are the only services deliberately exposed to simulate vulnerable endpoints. Communication between the honeypot and the ELK server is allowed for log ingestion and analysis. However, I intend to introduce stricter controls on this internal traffic in the future to further reduce the attack surface.\nFirewall configurationüß± For the pf(1) configuration It was as always with UNIX fairly easy to get to work:\nmatch in quick log on egress proto tcp from any to any port 22 flags S/SA rdr-to $honeypot port 2222 match in quick log on egress proto tcp from any to any port 443 flags S/SA rdr-to $honeypot port 4433 This rule makes sure any incoming TCP connection attempt to port 22 (SSH) and port 443 (HTTPS) is immediately intercepted, logged, and transparently redirected to the $honeypot server listening on port 2222 or 4433 for HTTPS Traffic.\nSwitch configuration Here you can see my managed switch configuration. Port 5 (honeypot) is only assigned to VLAN210 like port 5 too, port 2 is the router it needs to talk into both networks and at port 1 is my workstation to access the theathunting environment.\nWhat I Learned Building and maintaining this lightweight honeypot and monitoring setup on Raspberry Pi devices has been an insightful experience. Here are some key takeaways:\nResource Efficiency: Raspberry Pis provide a surprisingly capable platform for running complex services like Cowrie honeypot and the ELK stack in Docker containers, keeping costs and power consumption low.\nNetwork Segmentation Matters: Isolating the honeypot and ELK server in a dedicated VLAN (VLAN210) effectively contains malicious traffic, protecting the rest of the home network from potential threats.\nControlled Access Is Crucial: Restricting external access to only authorized clients and limiting the honeypot‚Äôs internet connectivity reduces the attack surface while still enabling useful data collection.\nLogging and Data Collection: Using Filebeat to ship logs from the honeypot to the ELK stack provides real-time visibility into attacker behavior, which is essential for threat hunting and incident response.\nCustomization Pays Off: Adapting existing tools and SIEM projects (like DShield) to specific needs improves effectiveness and allows for tailored threat detection.\nFuture Improvements: There is always room to tighten internal communication rules and harden the setup further to minimize risk and improve operational security.\nThis project highlights the balance between practical constraints and security needs, demonstrating that even modest hardware can contribute significantly to threat intelligence and network defense.\nI drew inspiration for this setup from the DShield SIEM project by SANS and would like to express my gratitude for their valuable work.\nWhats next Next I had to build the ssh honeypot and the HTTP Honeypot, stay tuned for the follow up!\nDONE Threat hunting II: SSH Honeypot setup @threathuntinghoneypot Introduction This post provides a brief walkthrough of how to deploy a lightweight, containerized SSH honeypot using Cowrie and Podman, with the goal of capturing and analyzing malicious activity as part of my threat hunting strategy.\nWhat is Cowrie? Cowrie is an interactive SSH and Telnet honeypot designed to emulate a real system, capturing attacker behavior in a controlled environment. It allows defenders and researchers to observe malicious activity without exposing actual infrastructure.\nKey capabilities of Cowrie include\nFull session logging: Records all commands entered by the attacker, along with input/output streams and timing data. Sessions can be saved as plaintext or in formats suitable for replay.\nFake file system and shell environment: Emulates a basic Linux shell with a user-modifiable file system. Attackers can navigate directories, read/write fake files, or attempt to download/upload payloads.\nCommand emulation: Supports a large set of common Unix commands (`ls`, `cat`, `wget`, etc.), allowing attackers to interact naturally, as if on a real system. And can be extended with more commands\nCredential logging: Captures usernames and passwords used in brute-force login attempts or interactive logins.\nFile download capture: Logs and optionally stores any files attackers attempt to retrieve via `wget`, `curl`, or similar tools.\nJSON-formatted logging and integration‚Äôs: Outputs structured logs that are easy to parse and ingest into systems like ELK, Splunk, or custom analysis pipelines.\nCowrie is widely used in research, threat intelligence, and proactive defense efforts to gather Indicators of Compromise (IOCs) and understand attacker tactics,techniques, and procedures (TTPs).\nWhy Podman over Docker? Podman offers several advantages over Docker, particularly in terms of security and system integration. It supports rootless containers, allowing users to run containers without elevated privileges, which reduces the attack surface.\nPodman is daemon-less, integrating more seamlessly with systemd and existing Linux workflows. Additionally, Podman is fully compatible with the Open Container Initiative (OCI) standards, ensuring interoperability and flexibility across container ecosystems.\nPreconditions / System setup Before I proceed with the cowrie setup, I made sure the following preconditions are met:\nUbuntu Installed on Raspberry Pi 4+ I am using a Raspberry Pi 4+ running Ubuntu\nSystem Fully Updated After installation, I made sure system is up to date:\nsudo apt update \u0026\u0026 sudo apt upgrade -y Podman installed and working # Ubuntu 20.10 and newer sudo apt-get -y install podman Run the Hello World Container.In this moment I did not had the cowrie user yet setup so I used my system user to test\npodman run hello-world Trying to pull docker.io/library/hello-world:latest... ... Hello from Docker! This message shows that your installation appears to be working correctly. tho sometimes the pulling fails like that then I had to put `docker.io` in front of the container name like:\npodman run docker.io/hello-world then it would work for sure.\nVLAN Tagging Configured on Network Interface In my network setup for threathunting the honeypot requires VLAN tagging to configured to reachable from the outside, VLAN210 is my restricted Network. Therefore i needed to configure the vlan using nmcli so it‚Äôs persistent across reboots.\nExample: Create a VLAN interface (e.g., VLAN ID 210 on main if)\nsudo nmcli con add type vlan con-name vlan210 dev mainif id 210 ip4 192.168.210.3/24 gw4 192.168.210.1 sudo nmcli con up vlan210 con-name vlan210: Name of the new VLAN connection. dev mainif: Physical interface to tag. id 210: VLAN ID. ip4, gw4: Optional IP and gateway assignment. This will persist the configuration and activate the VLAN interface immediately. Next I moved on to Install the honeypot.\nSetup environment, install cowrie as container and adjust configuration üêß Create a Dedicated User for Cowrie (No Login Shell) Running the Podman container under a dedicated system user with no login shell is a recommended security best practice. Reasons include:\nPrivilege Separation: Isolates the container from other system processes and users, limiting the potential impact of a compromise.\nReduced Attack Surface: The user has no login shell (e.g., /usr/sbin/nologin), meaning it can‚Äôt be used to log into the system interactively.\nAuditing \u0026 Logging: Helps distinguish container activity in system logs and process lists, making monitoring easier.\nLeast Privilege Principle: The user has only the permissions necessary to run the container ‚Äî nothing more.\n1. Create the ‚Äòcowrie‚Äô user (no home directory, no login shell)\nsudo useradd --system --no-create-home --shell /usr/sbin/nologin cowrie 2. Create necessary directories and set ownership\nsudo mkdir -p /opt/cowrie/etc sudo mkdir -p /opt/cowrie/var sudo chown -R cowrie:cowrie /opt/cowrie üê≥ Pull and Configure Cowrie with Podman 3. As the cowrie user, pull the container image\nsudo -u cowrie podman pull docker.io/cowrie/cowrie 4. Copy default config file into persistent volume\nsudo -u cowrie podman run --rm cowrie/cowrie \\ cat /cowrie/cowrie-git/etc/cowrie.cfg.dist \u003e /opt/cowrie/etc/cowrie.cfg üõ† cowrie.cfg ‚Äì Basic Overview The `cowrie.cfg` file is the main configuration for Cowrie, the SSH/Telnet honeypot we use. It uses INI-style syntax and is divided into sections. Each section begins with a header like [section_name].\nüìÅ Key Sections \u0026 Settings\n[ssh] / [telnet]\nEnable or disable SSH/Telnet and set the port to listen on:: enabled = true listen_port = 2222 [honeypot]\nSet honeypot host name and logpath properties:\nhostname = cowrie-host # Directory where to save log files in. log_path = var/log/cowrie Define login behavior:\nauth_class = AuthRandom auth_class_parameters = 1, 5, 10 I use AuthRandom here which causes to allow access after ‚Äúrandint(2,5)‚Äù attempts. This means the threat actor will fail with some logins and some will be logged in immediately.\n[output_jsonlog]\nConfigure logging and output plugins: [output_jsonlog] enabled = true logfile = ${honeypot:log_path}/cowrie.json epoch_timestamp = false This sets the default log location in the file-system, this is important so that file beat later can pickup on the juicy honeypot log files. This is the whole configuration needed to run the honeypot.\nüìå Notes\nRestart Cowrie after configuration changes. The configuration can be split across multiple `.cfg` files in `cowrie.cfg.d/` for modular setup. üöÄ Run Cowrie Container as ‚Äòcowrie‚Äô User Once I had created the dedicated system user (see earlier section), I was able to run the Cowrie container with Podman using sudo -u and a secure UID mapping.\nStep-by-Step Command explanation\nsudo -u cowrie podman run -d --name cowrie \\ --uidmap 0:$(id -u cowrie):1 \\ -v /opt/cowrie/etc:/cowrie/cowrie-git/etc:Z \\ -v /opt/cowrie/var:/cowrie/cowrie-git/var:Z \\ -p 2222:2222 \\ cowrie/cowrie Explanation\nsudo -u cowrie: Runs the Podman command as the unprivileged cowrie user. --uidmap 0:$(id -u cowrie):1: Maps root (UID 0) inside the container to the cowrie UID on the host. -v /opt/cowrie/etc and /opt/cowrie/var: Mounts configuration and data volumes from the host with `:Z` to apply correct SELinux labels (optional on systems without SELinux). -p 2222:2222: Forwards port 2222 from host to container (Cowrie‚Äôs SSH honeypot port). cowrie/cowrie: The container image name (use latest or specific tag as needed). Benefits:\nContainer runs as non-root on the host: Even if a process inside the container thinks it‚Äôs root, it‚Äôs actually limited to the unprivileged cowrie user outside the container.\nEnhanced security: If the container is compromised, the attacker only gets access as the cowrie user ‚Äî not real root.\nAvoids root-equivalent risks: Prevents privilege escalation or access to sensitive host files and devices.\nüéØ Operating the Honeypot View logs I think to know how to debug the container is important so we start first with the logs:\nsudo -u cowrie podman logs -f cowrie ...snip... [HoneyPotSSHTransport,14,10.0.2.100] Closing TTY Log: var/lib/cowrie/tty/e52d9c508c502347344d8c07ad91cbd6068afc75ff6292f062a09ca381c89e71 after 0.8 seconds [cowrie.ssh.connection.CowrieSSHConnection#info] sending close 0 [cowrie.ssh.session.HoneyPotSSHSession#info] remote close [HoneyPotSSHTransport,14,10.0.2.100] Got remote error, code 11 reason: b'disconnected by user' [HoneyPotSSHTransport,14,10.0.2.100] avatar root logging out [cowrie.ssh.transport.HoneyPotSSHTransport#info] connection lost [HoneyPotSSHTransport,14,10.0.2.100] Connection lost after 2.8 seconds ...snip... Restart container If things go left just restart that thing:\nsudo -u cowrie podman restart cowrie In the logs you can see that cowrie is running and accepting SSH connections:\n...snip... [-] CowrieSSHFactory starting on 2222 [cowrie.ssh.factory.CowrieSSHFactory#info] Starting factory \u003ccowrie.ssh.factory.CowrieSSHFactory object at 0x7fb66f26d0\u003e [-] Ready to accept SSH connections ...snip... When the log says ‚ÄúReady to accept SSH connections‚Äù I tested if I could login:\nssh 192.168.210.3 -p 2222 -l root root@192.168.210.3 password: The programs included with the Debian GNU/Linux system are free software; the exact distribution terms for each program are described in the individual files in /usr/share/doc/*/copyright. Debian GNU/Linux comes with ABSOLUTELY NO WARRANTY, to the extent permitted by applicable law. root@svr04:~# uname -a Linux svr04 3.2.0-4-amd64 #1 SMP Debian 3.2.68-1+deb7u1 x86_64 GNU/Linux root@svr04:~# Stop container Nothing special here:\nsudo -u cowrie podman stop cowrie üîÑ Automatically Restart Cowrie Podman Container with systemd To keep your Cowrie container running reliably and restart it if it stops, use a systemd service with restart policies.\nStep 1: Generate a systemd Service File\nCreate `/etc/systemd/system/cowrie-container.service` with the following content:\n[Unit] Description=Cowrie Honeypot Podman Container After=network.target [Service] User=cowrie Group=cowrie Restart=on-failure RestartSec=10s ExecStart=/usr/bin/podman run -d --name cowrie \\ --uidmap 0:$(id -u cowrie):1 \\ -v /opt/cowrie/etc:/cowrie/cowrie-git/etc:Z \\ -v /opt/cowrie/var:/cowrie/cowrie-git/var:Z \\ -p 2222:2222 \\ cowrie/cowrie ExecStop=/usr/bin/podman stop -t 10 cowrie ExecStopPost=/usr/bin/podman rm cowrie ExecReload=/usr/bin/podman restart cowrie TimeoutStartSec=120 [Install] WantedBy=multi-user.target The `‚Äìrestart-policy=on-failure` makes systemd restart the container if it exits with a failure. Step 2: Enable the Service\nsudo systemctl daemon-reload sudo systemctl enable --now container-cowrie.service Step 3: (Optional) Add a Health Check Script\nTo detect if Cowrie stops accepting connections even if the container is still running, create a health check script running as cowrie:\nCreate `/usr/local/bin/check_cowrie.sh`:\n#!/bin/bash if ! nc -z localhost 2222; then echo \"Cowrie not responding, restarting container\" /usr/bin/podman restart cowrie /usr/local/bin/pushover.sh \"Cowrie was restarted!\" fi This restarts the service and sends out a notification via pushover.\nMake it executable:\nsudo chmod +x /usr/local/bin/check_cowrie.sh sudo chown cowrie:cowrie /usr/local/bin/check_cowrie.sh Create systemd service `/etc/systemd/system/check_cowrie.service`:\n[Unit] Description=Check Cowrie honeypot health [Service] User=cowrie Group=cowrie Type=oneshot ExecStart=/usr/local/bin/check_cowrie.sh Create systemd timer `/etc/systemd/system/check_cowrie.timer`:\n[Unit] Description=Run Cowrie health check every minute [Timer] OnBootSec=1min OnUnitActiveSec=1min Unit=check_cowrie.service [Install] WantedBy=timers.target Enable and start the timer:\nsudo systemctl daemon-reload sudo systemctl enable --now check_cowrie.timer Summary\nUsed Podman‚Äôs systemd integration for automatic restart on container failure. Added a health check timer to detect if Cowrie stops accepting connections and restart proactively. üîí Security Notes The `cowrie` user has no login shell (`/usr/sbin/no login`)\nRunning Cowrie isolated via Podman increases containment\nAll files are owned by `cowrie`, no root access required for normal operation\nLog Forwarding with Filebeat üì¶ Install Filebeat on Ubuntu 1. Add Elastic‚Äôs GPG key and repository\ncurl -fsSL https://artifacts.elastic.co/GPG-KEY-elasticsearch | sudo gpg --dearmor -o /usr/share/keyrings/elastic.gpg echo \"deb [signed-by=/usr/share/keyrings/elastic.gpg] https://artifacts.elastic.co/packages/8.x/apt stable main\" | \\ sudo tee /etc/apt/sources.list.d/elastic-8.x.list 2. Update APT and install Filebeat\nsudo apt install filebeat ‚öô Configure and test Filebeat 3. Edit Filebeat config\nsudo mg /etc/filebeat/filebeat.yml The filebeat config is straight forward. You have to write a filebeat.input block which contains the path where the logfiles are you need to ingest. And at the end the log-destination (logstash) so that filebeat knows where to send the logs to:\nfilebeat.inputs: - type: log enabled: true paths: - /opt/cowrie/var/log/cowrie/cowrie.json json.keys_under_root: true json.add_error_key: true fields: source: cowrie fields_under_root: true output.logstash: hosts: [\"192.168.123.5:5044\"] 4. (Optional) Test Filebeat config\nsudo filebeat test config logstash: 192.168.210.5:5044... connection... parse host... OK dns lookup... OK addresses: 192.168.210.5 dial up... OK TLS... WARN secure connection disabled talk to server... OK üöÄ Start and Enable Filebeat 5. Enable and start Filebeat\nsudo systemctl enable filebeat sudo systemctl daemon-reload sudo systemctl start filebeat 6. Check Filebeat status and logs\nsudo systemctl status filebeat sudo journalctl -u filebeat -f üéØ TL;DR ‚Äì What Did We Just Do? 1. We deployed Cowrie like pros.\nRan it safely in a Podman container under a non-login user. No mess, no root, no regrets. 2. Logs? Sorted.\nFilebeat scooped up Cowrie‚Äôs logs and shipped them to Elasticsearch. Now we can actually see who‚Äôs knocking on the honeypot door. 3. Everything‚Äôs persistent.\nConfigs and logs live outside the container. Cowrie forgets nothing‚Äîeven after a reboot. 4. Setup is clean and modular.\nEach part (Cowrie, Filebeat, Elasticsearch) does its job. Break one, fix one‚Äîno domino disasters. 5. It‚Äôs nerdy, useful, and kinda fun.\nNow I built a mini threat intel system. Now I can sit back, sip coffee, and watch the kiddies play. Whats next Next I build the HTTP Honeypot\nDONE Threathunting III: HTTP Honeypot develop and setup @threathuntinghoneypot Introduction Brief overview of the use case I recently set out to ingest web traffic data into my SIEM solution, which requires data to be ingested in a specific format. After researching various options, I sought an easy-to-use solution that could integrate with our existing Elasticsearch setup. One tool that caught my attention was HoneyPot HTTPD.\nAs I researched potential solutions, I realized that many of them required manual configuration and scripting to ingest web data into Elasticsearch. However, HoneyPot HTTPD offered a simple and elegant way to do so through its built-in ingestion feature. This was especially appealing since I wanted to integrate the web traffic data with our existing SIEM setup that utilized Elasticsearch.\nIn particular, I needed a tool that could collect web traffic data and forward it to a centralized location for analysis and processing. Honeypot HTTPD‚Äôs ability to ingest web data into Elasticsearch made it an attractive choice, as it would allow me to leverage our existing Elasticsearch infrastructure and integrate the data with our SIEM solution seamlessly.\nWith this in mind, I set out to explore how to use HoneyPot HTTPD to ingest web traffic data into Elasticsearch. In the following sections, I‚Äôll walk you through the steps I took to configure HoneyPot HTTPD for ingestion, including the Dockerfile used to build the container and any additional configuration settings required.\nSetting up HoneyPot HTTPD for Web Data Ingestion and adjust code for our needs Containerizing the application to run inside docker Creating a Dockerfile\nI started by creating a Dockerfile that would build the HoneHTTPD image. The Dockerfile included the following instructions:\n# Use python base image FROM python:3 # Set environment ARG APP_NAME=honeyhttpd ENV APP_NAME=${APP_NAME} ARG USER_ID=\"10001\" ARG GROUP_ID=\"app\" ARG HOME=\"/app\" ENV HOME=${HOME} # Create user and environment RUN groupadd --gid ${USER_ID} ${GROUP_ID} \u0026\u0026 \\ useradd --create-home --uid ${USER_ID} --gid ${GROUP_ID} --home-dir /app ${GROUP_ID} # Install dependencies RUN apt-get update \u0026\u0026 \\ apt-get install -y --no-install-recommends \\ file \\ gcc \\ libwww-perl curl unzip \u0026\u0026 \\ apt-get autoremove -y \u0026\u0026 \\ apt-get clean # Set workdir WORKDIR ${HOME} # Copy config files and certs into container COPY ./requirements.txt . COPY ./config.json . COPY ./server*.pem . COPY ./ca.crt . COPY honeyhttpd logs servers util . COPY start.py . # Upgrade python packages and install dependencies RUN pip3 install --upgrade pip RUN pip3 install virtualenv RUN python3 -m virtualenv ${HOME} \u0026\u0026 \\ virtualenv ${HOME} RUN pip3 install --no-cache-dir --upgrade pip setuptools wheel elasticsearch==8.13.0 \u0026\u0026 \\ pip3 install --no-cache-dir --upgrade -r ./requirements.txt \u0026\u0026 pip3 install -r ./requirements.txt ADD . ${HOME} # Remove compilers RUN apt-get remove gcc --purge -y # Drop root and change ownership of the application folder to the user RUN chown -R ${USER_ID}:${GROUP_ID} ${HOME} USER ${USER_ID} # Expose Honeypot ports to outside world EXPOSE 8443:8443 # run cowrie with config CMD [\"python3\", \"start.py\", \"--config\", \"config.json\"] In this Dockerfile, I:\nUsed the official Ubuntu image as the base image Installed necessary dependencies, including Python and pip Installed the required packages, including HoneyPot HTTPD Set the working directory to /usr/local/bin to run the application from Exposed port 80 for HTTP traffic Copied the configuration file (config.yaml) into the container Specified the command to run HoneyPot HTTPD with the -c option, which points to the configuration file Building and Running the Container\nOnce I had created the Dockerfile, I built the image by running the following command:\nsudo docker build -t honeyhttpd . This command told Docker to create an image with the tag honeyhttpd using the instructions in the Dockerfile.To run the container, I used the following command:\nsudo docker run --hostname honeyhttpd -p 8443:8443 honeyhttpd This command started a new container from the honeyhttpd image and mapped port 8443 on the host machine to the port 8443 in the container.\nConfiguring the Container\nTo configure the honeypot, I updated the config.yaml file to point to my Elasticsearch instance. Here‚Äôs an example of what the configuration file might look like:\n\"loggers\": { \"ElasticSearchLogger\": { \"active\": true, \"config\": { \"server\": \"https://192.168.210.95:9200\", \"verify_certs\": true, \"username\": \"elastic\", \"password\": \"SecretPassword\", \"index\": \"cowrie.webhoneypot\", } } the server config itself is quite simplistic:\n\"servers\" : [ {\"handler\": \"ApachePasswordServer\", \"mode\": \"https\", \"port\": 8443, \"domain\": \"cooldomain.com\", \"timeout\": 10, \"cert_path\": \"server_cert.pem\", \"key_path\": \"server_key.pem\"}, ], \"user\": \"nobody\", \"group\": \"nogroup\" } This configuration told HoneyPot HTTPD to forward web traffic data to my Elasticsearch instance, where it could be processed and stored.\nFor the cert_path and key_path we earlier copied the self signed cert and key to the container.\nWith the container running and configured, I was now ready to test HoneyPot HTTPD‚Äôs ability to ingest web traffic data into Elasticsearch.\nWhich I did with just opening https://honeypot.home.arpa:8443 in my webbrowser. Which gave me the htpasswd auth prompt.\nüöÄ Code adjustments for our environment I started from the original ApachePasswordServer in honeyhttpd, which was fairly minimal‚Äîit simply responded with a 401 on selected paths and captured credentials in a rudimentary way. I overhauled it to better structure logging, extract metadata, and sanitize inputs before sending logs to Elasticsearch.\nBelow, I explain each change with commentary.\nüîê Improvements in ApachePasswordServer.py: Credential Logging and Header Parsing\nThis update significantly extends the functionality of ApachePasswordServer.py. It builds on the original honeyhttpd implementation by enhancing its ability to simulate Basic Authentication, extract and decode credentials from the `Authorization` header, and log structured metadata about each HTTP request and response.\nIt now integrates tightly with an `ElasticSearchLogger`, providing enriched, sanitized logs for further analysis or visualization. Custom helper functions ensure safe parsing, while connection and client metadata offer greater context to the captured events.\nüìä Summary of Changes\n2 files changed: ApachePasswordServer.py and Elasticsearchlogger.py Key improvements: Simulation of Basic Auth (401 challenge on sensitive paths) Credential extraction and decoding from `Authorization` header Connection metadata collection (IP, port, useragent etc.) Header parsing with case-insensitive lookup Structured request and response logging Integration with `ElasticSearchLogger` Safer JSON serialization and error handling Here I describe how I extended the honeypot server to improve credential logging and integrate with Elasticsearch for structured logging.\nStarting from a basic server that simply issued 401 responses, I added features to parse HTTP requests, decode Basic Auth headers, and enrich logs with request and connection metadata. This makes the server far more useful for DFIR research and threat hunting.\nOriginal baseline from (for reference)\nBig thanks to the great ground wrok from bocajspear1 over at github with the honeyHTTPD Server. That way I did not had to write all from scratch. But I still had to make some improvements in order to use the honeypot in my Environment.\nfrom servers.ApacheServer import ApacheServer import honeyhttpd.lib.encode as encode class ApachePasswordServer(ApacheServer): def on_request(self, handler): return None, None def on_GET(self, path, headers): if path == \"/\" or path == \"/index.php\" or path == \"/admin\": return 401, [], \"Basic realm=\\\"Secure Area\\\"\" return 404, [], \"\" def on_POST(self, path, headers, post_data): return 404, [], \"\" def on_error(self, code, headers, message): return code, [(\"Connection\", \"close\"), (\"Content-Type\", \"text/html; charset=iso-8859-1\")], message def on_complete(self, client, code, req_headers, res_headers, request, response): extra = {} for header in req_headers: if header[0].lower() == \"authorization\": auth_split = header[1].split(\" \") if len(auth_split) \u003e 1: auth_data = auth_split[1] extra['creds'] = encode.decode_base64(auth_data) self.log(client, request, response, extra) def default_headers(self): return [] üÜï Auto-Injection of `ElasticSearchLogger` in `_init_()`\nTo ensure consistent structured logging, `ElasticSearchLogger` is now injected into the logger stack if not already present.\n+ if loggers is None: + loggers = [] + if not any(isinstance(logger, ElasticSearchLogger) for logger in loggers): + loggers.append(ElasticSearchLogger()) This avoids missing logs if the user forgets to pass a logger during instantiation.\nüîê New GET Handler Simulates Apache Basic Auth Challenge\nThe server now returns `401 Unauthorized` and prompts for credentials on common admin paths.\n+ def on_GET(self, path, headers): + if path in [\"/\", \"/index.php\", \"/admin\"]: + return 401, [], 'Basic realm=\"Secure Area\"' + return 404, [], \"\" This turns the honeypot into a credential trap for automated brute-forcers and scanners.\nüß∞ New Helper Functions for Header Parsing and Auth Decoding\nTwo utility functions were introduced:\n`parse_to_json()` transforms header tuples into a JSON dictionary. `decode_basic_auth()` decodes Base64 credentials and validates them. def parse_to_json(data): return json.dumps({key: value for key, value in data}) def decode_basic_auth(b64_string): try: decoded_bytes = base64.b64decode(b64_string, validate=True) decoded_str = decoded_bytes.decode('utf-8') if ':' in decoded_str: return decoded_str else: return \"[invalid format: missing colon]\" except Exception as e: return f\"[decode error: {e}]\" These enable safe and consistent parsing for incoming HTTP headers.\nüì¶ Structured Request Parsing \u0026 Credential Extraction in `on_complete()`\nThe `on_complete()` method has been completely reworked to:\nParse the HTTP request line Convert headers to a JSON object Extract relevant metadata and credentials Store all data in `req_dict`, passed to the logger - extra = {} + req_dict = {} ... + lines = request.split('\\n') + first_line = lines[0].strip() + parts = first_line.split() + requested_url = parts[1] if len(parts) \u003e 1 else \"\" + method = parts[0] if len(parts) \u003e 0 else \"\" + req_dict['request_body'] = requested_url + req_dict['method'] = method + req_dict['code'] = code + + try: + req_output = parse_to_json(req_headers) + parsed_req = json.loads(req_output) + except Exception as e: + parsed_req = {} + + for key in ['Host', 'User-Agent', 'Accept', 'Accept-Language', + 'Accept-Encoding', 'Authorization']: + req_dict[key] = parsed_req.get(key, '') + + auth = parsed_req.get('Authorization', '') + if auth.startswith(\"Basic \"): + try: + auth_data = auth.split(\" \", 1)[1] + decoded_creds = encode.decode_base64(auth_data) + req_dict['creds'] = decoded_creds + except Exception as e: + req_dict['creds'] = f\"[decode error: {e}]\" This prepares your logs to include useful hunting metadata for later analysis.\nüåê Enriched Connection Metadata Logging\nAdditional context is logged to `req_dict`, including:\nRemote IP and port SSL usage Listening port HTTP response code Response headers + remote_ip = client[0] if isinstance(client, tuple) else '' + remote_port = client[1] if isinstance(client, tuple) else '' + is_ssl = getattr(self, 'is_ssl', False) + port = getattr(self, 'port', '8843') + + req_dict['remote_ip'] = remote_ip + req_dict['remote_port'] = remote_port + req_dict['is_ssl'] = is_ssl + req_dict['port'] = port + req_dict['response_headers'] = res_dict + + self.log(client, request, response, res_dict, req_dict) This provides rich forensic data for Elasticsearch or Splunk pipelines.\nüîë Highlights\nüÜï Auto-injection of `ElasticSearchLogger` Ensures logs are never silently dropped, even if no logger is passed explicitly.\nüîê Basic Auth Simulation with 401 Challenge Returns `401 Unauthorized` on suspicious paths to bait scanners.\nüß∞ Safe Parsing \u0026 Decoding with Helpers New functions `parse_to_json()` and `decode_basic_auth()` added for reliability.\nüì¶ Structured Logging in `on_complete()` Fully rewritten to extract metadata, decode credentials, and prepare logs.\nüåê Rich Connection Context Logs IP, port, SSL usage, and full response headers for correlation.\nüß† Use Case\nThese changes upgrade ApachePasswordServer.py from a toy honeypot to a serious data source for threat hunting. It can now be safely deployed in research environments, logging attack metadata in structured formats ideal for analysis pipelines like Elasticsearch + Kibana or Splunk.\nüìù Conclusion üîë Key points about using HoneyPotHTTPD to ingest web data into Elasticsearch\nThis article detailed how I enhanced ApachePasswordServer.py to make the simple honeypot into a powerful tool for capturing attacker behavior. By simulating Apache Basic Authentication challenges and extracting credentials from incoming requests, I enabled my honeypot effectively to bait malicious actors.\nStructured parsing of HTTP requests and responses combined with integration into `ElasticSearchLogger` allows me to generate rich, queryable logs, complete with client metadata, HTTP headers, and decoded credentials.\nThis setup not only captures raw data but also organizes it in a way that facilitates downstream analysis using Elasticsearch or similar log management platforms.\nüí° Final thoughts\nDeploying this enhanced honeypot within your environment equips you with detailed, actionable insights into attacker tactics and techniques. The ability to collect and analyze credential attempts and associated metadata improves detection fidelity and supports incident response efforts.\nBy bridging the gap between mere detection and detailed forensic logging, this solution empowers proactive threat hunting and accelerates the identification of emerging attack patterns. Integrating it into your security operations stack can thus significantly boost your detection and defense capabilities.\nTODO - Extensive testing of the honeypot, there will be an article coming up how to do automated honeypot testing with Zap proxy, stay tuned!\nNext, we will talk about Setting up the ELK Server and how to ingest data. Stay tuned!\nDRAFT Threathunting IV: Setup ELK Server and ingest data @threathuntingvisibility DRAFT Testing webhoneypots with ZAP in server mode @threathunting",
    "description": "DONE Threathunting I: Network setup @threathuntinghoneypotvisibility Introduction This is a small series I wanted to start, where I write about my small threathunting setup and describe a little what I build and what I am doing with it.",
    "tags": [
      "Threathunting"
    ],
    "title": "Adventures in threathunting",
    "uri": "/posts/adventuresthreathunting/index.html"
  },
  {
    "breadcrumb": "Welcome",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tags",
    "uri": "/tags/index.html"
  },
  {
    "breadcrumb": "Welcome¬†\u003e¬†Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag - Threathunting",
    "uri": "/tags/threathunting/index.html"
  },
  {
    "breadcrumb": "Welcome",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Categories",
    "uri": "/categories/index.html"
  },
  {
    "breadcrumb": "Welcome¬†\u003e¬†Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag - Honeypot",
    "uri": "/tags/honeypot/index.html"
  },
  {
    "breadcrumb": "Welcome¬†\u003e¬†Categories",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Category - Threathunting",
    "uri": "/categories/threathunting/index.html"
  },
  {
    "breadcrumb": "Welcome¬†\u003e¬†Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag - Forensicwheels",
    "uri": "/tags/forensicwheels/index.html"
  },
  {
    "breadcrumb": "Welcome",
    "content": "What Burned Me Built Me I used to believe that the place I worked for meant something. That our mission was shared. That our values were real. That if you showed up with honesty, effort, and a willingness to carry more than your share ‚Äî you‚Äôd be met with respect. Or at least, fairness.\nI was wrong.\nDisappointment What hurts isn‚Äôt the exit itself. What hurts is realizing that the foundation I stood on was never really there at all. That the culture I believed in ‚Äî the one I helped build ‚Äî was, in the end, just an image.\nThat when things got hard, the masks stayed on, and the people I trusted turned away.\nThe Pull to React For a while, I wanted to fight. Not because I love conflict, but because the silence felt like betrayal.\nI wanted to prove something. To show them they were wrong about me. To remind them that I was worth more than the way they let me go.\nBut I‚Äôve chosen a different path.\nStillness I won‚Äôt drag names through the mud. I won‚Äôt post receipts or pass around whispers. Not because they deserve protection ‚Äî but because I deserve peace.\nWhat I build next will be louder than anything I could say.\nWhat Comes Next I have ideas. Good ones. Open source, threat hunting on a budget, monitoring stacks that actually work, stories about real resilience in the face of bullshit.\nI know what I‚Äôve built. I know what I can offer. And I‚Äôll keep showing up ‚Äî not for them, but for the part of me that never wanted to be anything but real.\nFinal Note To those who watched in silence as I burned ‚Äî I hope the quiet served you well.\nTo those who ever believed in me ‚Äî I‚Äôm still here.\nAnd to myself ‚Äî This is where it begins again. With truth, and with clarity.\n‚ÄúThe fire that consumed my old world is now the light that guides me forward.‚Äù\nFeedback and Comments",
    "description": "What Burned Me Built Me I used to believe that the place I worked for meant something. That our mission was shared. That our values were real. That if you showed up with honesty, effort, and a willingness to carry more than your share ‚Äî you‚Äôd be met with respect. Or at least, fairness.\nI was wrong.\nDisappointment What hurts isn‚Äôt the exit itself. What hurts is realizing that the foundation I stood on was never really there at all. That the culture I believed in ‚Äî the one I helped build ‚Äî was, in the end, just an image.",
    "tags": [
      "Forensicwheels"
    ],
    "title": "Just a shell",
    "uri": "/justashell/index.html"
  },
  {
    "breadcrumb": "Welcome¬†\u003e¬†Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag - Visibility",
    "uri": "/tags/visibility/index.html"
  },
  {
    "breadcrumb": "Welcome¬†\u003e¬†Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag - Openbsd",
    "uri": "/tags/openbsd/index.html"
  },
  {
    "breadcrumb": "Welcome¬†\u003e¬†Categories",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Category - Personal",
    "uri": "/categories/personal/index.html"
  },
  {
    "breadcrumb": "Welcome¬†\u003e¬†Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag - Zen",
    "uri": "/tags/zen/index.html"
  },
  {
    "breadcrumb": "Welcome¬†\u003e¬†Tags",
    "content": "",
    "description": "",
    "tags": [],
    "title": "Tag - Personal",
    "uri": "/tags/personal/index.html"
  }
]
